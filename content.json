{"meta":{"title":"Suy's Blog","subtitle":"Everything will be ok","description":" ","author":"0w0suy","url":"https://0w0suy.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-07-20T16:03:52.000Z","updated":"2021-07-20T16:04:17.427Z","comments":true,"path":"categories/index.html","permalink":"https://0w0suy.github.io/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2021-07-20T16:04:47.000Z","updated":"2021-07-20T16:05:08.967Z","comments":true,"path":"link/index.html","permalink":"https://0w0suy.github.io/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-20T16:02:41.000Z","updated":"2021-07-20T16:03:07.306Z","comments":true,"path":"tags/index.html","permalink":"https://0w0suy.github.io/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2021-07-24T01:10:40.000Z","updated":"2021-07-24T01:21:02.890Z","comments":true,"path":"music/index.html","permalink":"https://0w0suy.github.io/music/index.html","excerpt":"","text":""},{"title":"gallery","date":"2021-07-20T23:53:35.000Z","updated":"2021-07-21T00:07:40.867Z","comments":true,"path":"gallery/index.html","permalink":"https://0w0suy.github.io/gallery/index.html","excerpt":"","text":""}],"posts":[{"title":"CTF之常见密码学攻击手法和实现","slug":"CTF之常见密码学攻击手法和实现","date":"2021-08-03T05:13:29.000Z","updated":"2021-08-03T12:25:34.882Z","comments":true,"path":"2021/08/03/CTF之常见密码学攻击手法和实现/","link":"","permalink":"https://0w0suy.github.io/2021/08/03/CTF%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%AF%86%E7%A0%81%E5%AD%A6%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"题目均来源CTF 通过了解CTF中常见和以前奇葩题型，有助于我们学习更多的内容 关于rsa的一些基础知识之前就有写过啦，这篇直接开始做题 O(∩_∩)O 已知p,q,e 求d题目RSA如下 直接带入即可 1234567import gmpy2p=473398607161q=4511491e=17fai=(p-1)*(q-1)d=gmpy2.invert(e,fai)print(&#x27;d=&#x27;,d) 输出结果 1d= 125631357777427553 所以答案套个flag{} 1flag&#123;125631357777427553&#125; 已知p,q,e,c 求m题目rsarsa如下 求解，比上一题多一个步骤而已 123456789101112import gmpy2p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034n=p*qfai=(p-1)*(q-1)d=gmpy2.invert(e,fai)m=pow(c,d,n)print(&#x27;m=&#x27;,m) 输出结果 1m= 5577446633554466577768879988 所以答案是 1flag&#123; 5577446633554466577768879988&#125; 已知p,q,dp,dq,c 求m题目RSA1如下 12345p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 对新出现的dp，dq先来分析一下，直接手写了hhh 解题 1234567891011121314151617181920212223import gmpy2import libnump = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852niyuan=gmpy2.invert(p,q)n=p*qmp=pow(c,dp,p)mq=pow(c,dq,q)m=(((mp-mq)*niyuan % p)*q+mq)%nprint(&#x27;m=&#x27;,m)hex_m=hex(m)print(hex_m)import binasciimingwen= binascii.unhexlify(&#x27;6e6f784354467b57333163306d335f37305f4368316e343730776e7d&#x27;)print(mingwen) 输出结果 123m= 11630208090204506176302961171539022042721137807911818876637821759101 0x6e6f784354467b57333163306d335f37305f4368316e343730776e7d b&#x27;noxCTF&#123;W31c0m3_70_Ch1n470wn&#125;&#x27; 所以答案 1flag&#123;W31c0m3_70_Ch1n470wn&#125; 已知e,n,dp.c 求m题目 1234e = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751 分析一波只含dp的情况 现在来解题 1234567891011121314151617181920212223242526import gmpy2import libnume = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751for x in range(1,e): #在(1,e)中遍历取一个数x if (dp*e-1)%x==0: ​ if n%(((dp*e-1)//x)+1) == 0: #存在p，使得n能被p整除​ p=((dp*e-1)//x)+1 #求p​ q=n//p #求q​ fai=(p-1)*(q-1) ​ d=gmpy2.invert(e,fai) ​ m=pow(c,d,n) print(&#x27;m=&#x27;,m)hex_m=hex(m)print(hex_m)import binascii mingwen= binascii.unhexlify(&#x27;666c61677b776f775f6c65616b696e675f64705f627265616b735f7273613f5f39383932343734333530327d&#x27;)print(mingwen) 输出结果为 123m= 3670434958110785066911905751469631231338751225710158680692616521935747246580688484040488309932916523151997 0x666c61677b776f775f6c65616b696e675f64705f627265616b735f7273613f5f39383932343734333530327d b&#x27;flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125;&#x27; 因此答案为 1flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125; 已知c1,c2,e1,e2,n 求m题目RSA3如下 12345c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291 解题 12345678910111213141516171819202122232425262728293031323334from gmpy2 import invertdef gongmogongji(n, c1, c2, e1, e2): def egcd(a, b): if b == 0: return a, 0 else: x, y = egcd(b, a % b) return y, x - (a // b) * y s = egcd(e1, e2) s1 = s[0] s2 = s[1] # 求模反元素 if s1 &lt; 0: s1 = - s1 c1 = invert(c1, n) elif s2 &lt; 0: s2 = - s2 c2 = invert(c2, n) m = pow(c1, s1, n) * pow(c2, s2, n) % n return mc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291result = gongmogongji(n, c1, c2, e1, e2)print(result)m=13040004482819947212936436796507286940525898188874967465457845309271472287032383337801279101hex_m=hex(m) print(hex_m)import binascii mingwen=binascii.unhexlify(b&#x27;666c61677b34396439313037376131616263623134663161396435343663383062653965667d&#x27;)print(mingwen) 输出结果即答案 1flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125; 已知flag.enc,pub.key 求m将pub.key的后缀改为txt，打开 123-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+/AvKr1rzQczdAgMBAAE=-----END PUBLIC KEY----- 之前写过一篇用虚拟机openssl命令解key的，后来发现在线网站也可以实现 SSL在线工具-公钥解析 (ssleye.com) 12n=86934482296048119190666062003494800588905656017203025617216654058378322103517e=65537 再分解n 12p=285960468890451637935629440372639283459q=304008741604601924494328155975272418463 后来我又get到一个方便的tool，可以直接计算d 1d=81176168860169991027846870170527607562179635470395365333547868786951080991441 1234567891011121314import gmpy2import rsae= 65537n= 86934482296048119190666062003494800588905656017203025617216654058378322103517p= 285960468890451637935629440372639283459q= 304008741604601924494328155975272418463d= 81176168860169991027846870170527607562179635470395365333547868786951080991441key = rsa.PrivateKey(n,e,d,q,p) with open(r&quot;C:\\Users\\Lenovo\\Desktop\\0eaf8d6c-3fe5-4549-9e81-94ac42535e7b (1)\\flag.enc&quot;,&quot;rb&quot;) as f: f = f.read() print(rsa.decrypt(f,key)) 输出结果 1b&#x27;flag&#123;decrypt_256&#125; 已知n,e,c 求m，且c为字符串题目RSAROLL如下，有两个文件 1234567891011121314151617181920212223242526272829303132333435363738394041#data.txt&#123;920139713,19&#125;70479679275221115227470416418414022368270835483295235263072905459788476483295235459788476663551792475206804459788476428313374475206804459788476425392137704796792458265677341524652483295235534149509425392137428313374425392137341524652458265677263072905483295235828509797341524652425392137475206804428313374483295235475206804459788476306220148 12345#题目.txtRSA roll！roll！roll！Only number and a-z（don&#x27;t use editorwhich MS provide） 1234567891011121314151617import gmpy2 import libnumn = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793c = 0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365i = 0while 1: if(gmpy2.iroot(c+i*n,3)[1]==1): print(gmpy2.iroot(c+i*n,3)) break i=i+1hex_m=hex(13040004482819713819817340524563023159919305047824600478799740488797710355579494486728991357)print(hex_m)import binasciimingwen=binascii.unhexlify(&#x27;666c61677b32356466386361663030366565356462393464343831343463333362326333627d&#x27;)print(mingwen) 123(mpz(13040004482819713819817340524563023159919305047824600478799740488797710355579494486728991357), True)0x666c61677b32356466386361663030366565356462393464343831343463333362326333627db&#x27;flag&#123;25df8caf006ee5db94d48144c33b2c3b&#125;&#x27; 1flag&#123;25df8caf006ee5db94d48144c33b2c3b&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://0w0suy.github.io/categories/CTF/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://0w0suy.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"消息认证与数字签名","slug":"消息认证与数字签名","date":"2021-08-02T05:12:39.000Z","updated":"2021-08-02T15:03:54.984Z","comments":true,"path":"2021/08/02/消息认证与数字签名/","link":"","permalink":"https://0w0suy.github.io/2021/08/02/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/","excerpt":"","text":"数字签名验证实验定义数字签名，又称公钥数字签名、电子签章，是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，一个用于验证。简单地说，所谓数字签名就是附加在原来数据上一些数据或者对原来数据做一些密码变换。这种数据或变换允许数据单元的接收者用以确认数据单元的来源和数据单元的完整性并保护数据，防止被人(例如接收者)进行伪造。 基于公钥密码体制和私钥密码体制都可以获得数字签名，主要是基于公钥密码体制的数字签名。包括普通数字签名和特殊数字签名。 普通数字签名算法：RSA、ElGamal、Fiat-Shamir、Guillou-Quisquarter、Schnorr、Ong-Schnorr-Shamir数字签名算法、Des/DSA、椭圆曲线数字签名算法、有限自动机数字签名算法 特殊数字签名：盲签名、代理签名、群签名、不可否认签名、公平盲签名、门限签名、具有消息恢复功能的签名 功能保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生 解释：数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。 数字签名的过程 利用一定的算法(如MD5)，将要签名的报文作为一个散列函数的输入，产生一个定长的安全散列码，即消息摘要； 使用发送方的私有密钥对这个消息摘要进行加密，形成签名； 将报文和签名传送出去； 接收方接收报文，并根据报文产生一个消息摘要，同时使用发方的公开密钥对签名进行解密； 如果接收方计算得出的消息摘要，和它解密后的签名互相匹配，那么签名就是有效的； 因为只有发送方知道私有密钥，并对签名进行了加密，因此只有发方才能产生有效的签名。 对文件做签名验证在实验机里打开cmd控制台，进入sigcheck程序目录，输入sigcheck，点击回车，会出现使用说明 以存在的calc为例，把calc所在路径复制到cmd 1sigcheck C:\\windows\\system32\\calc.exe 如下图，会出现，signed，即被签名 现在我们试试另外一个文件 1sigcheck helloworld.exe 很显然，unsigned，这是没有被签名的文件 批量验证文件签名从上面实验我们可以看到一个一个试文件很繁琐麻烦，很多情况下，我们需要找出某个目录里所有未经过数字签名的文件 1sigcheck -e C:\\windows\\System32 &gt;abc.txt 执行后可以查看abc.txt文件，发现都是经过数字签名后的 单向哈希函数与mac我们现在虚拟机上的终端运行 1vim 1.txt 创建一个文件，本人不知道vim的命令语法，于是上万能的百度，现在例举用到的操作 插入模式（按i键进入） 左下角显示–INSERT– 命令模式（按ESC键退出） 输入：wq :w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出vi:q 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑命令历史 1openssl dgst -md5 1.txt 顾名思义，dgst就是消息摘要，这里我们用md5加密 我们试试sha1加密 1openssl dgst -sha1 1.txt -hmac指的是加盐加密，我们分别用abcd,abcde,abcdef来加盐，可以看到一个字母的添加带来翻天覆地变化，但是长度都是固定的 123openssl dgst -sha1 -hmac”abcd” 1.txtopenssl dgst -sha1 -hmac”abcde” 1.txtopenssl dgst -sha1 -hmac”abcdef” 1.txt 现在我们再创建两个txt，分别用MD5进行加密 12openssl dgst -md5 2.txtopenssl dgst -md5 2.txt 我们可以看到数字一样但是位置不一样的文件，它的MD5是完全不一样的，且没有任何规律 12cat 2.txtcat 3.txt powershell调用DLL实现RSA签名定义powershell简介PowerShell是运行在windows机器上实现系统和应用程序自动化管理的命令行脚本环境，是cmd.exe命令行提示符的加强版。它有很好的可读性和易用性。 DLL DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用程序拓展”，是软件文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。 RSA签名验证机制RSA的签名验证用于通信数据防篡改，如图 实验1234567public void RSAKey(out string xmlKeys, out string xmlPublicKey) //生成RSA密钥对 public void GetHash(string strSource, ref string strHashData) // 获取hash摘要 public void SignatureFormatter(string strKeyPrivate, string strHashbyteSignature, ref string strEncryptedSignatureData) //RSA签名 public bool SignatureDeformatter(string strKeyPublic, string strHashbyteDeformatter, string strDeformatterData) // RSA验签 在Powershell中调用操作系统的RSA类库 1RSACryption.ps1 从中获取明文hash摘要 1CheckSigned.ps1 签名验证结果返回True，如图所示，表明签名验证结果是正确的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://0w0suy.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"哈希函数算法实现原理和应用","slug":"哈希函数算法实现原理和应用","date":"2021-07-31T05:12:00.000Z","updated":"2021-08-01T00:27:19.282Z","comments":true,"path":"2021/07/31/哈希函数算法实现原理和应用/","link":"","permalink":"https://0w0suy.github.io/2021/07/31/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/","excerpt":"","text":"hash，一般翻译做“散列”，也有直接音译为”哈希” 就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值。 MD（Message Digest )，为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。目前广泛使用的是第五版，因此也被称为MD5。 MD5和SHA1可以说是目前应用最广泛的Hash算法，而它们都是以MD4为基础设计的。 MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹），以防止被“篡改”。 举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现（两个MD5值不相同）。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。 MD5加解密在线网站MD5在线加密/解密/破解—MD5在线 (sojson.com) 明文是2021加密后 选取任意一组密文 进行解密 但是稍微复杂一点的字母就解不出来了唉 Hash算法MD5分析MD5算法的原理对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 首先是对信息进行填充，使其位长对512求余的结果=448 因此，原来信息的位长应该为N*512+448 填充的方法：在原信息后补一个1和许多0，直到满足条件 填充完毕后，在这个结果后面加一个以64位二进制表示的填充前的信息长度 因此，现在的消息位长=N*512+448+64=(N+1)*512，这样的长度刚好是512的整数倍 流程图如下： 表示第i个分组，每次的运算都由前一轮的128位结果值和第i块512bit值进行运算。初始的128位值为初始链接变量，这些参数用于第一轮的运算，他们分别为：A=0x01234567，B=0x89ABCDEF，C=0xFEDCBA98，D=0x76543210。 每一分组的算法流程如下： 第一分组需要将上面四个链接变量复制到另外四个变量中： A到a，B到b，C到c，D到d。 从第二分组开始的变量为上一分组的运算结果。 主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向左环移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。 以一下是每次操作中用到的四个非线性函数（每轮一个）。 12345F(X,Y,Z) =(X&amp;Y)|((~X)&amp;Z)G(X,Y,Z) =(X&amp;Z)|(Y&amp;(~Z))H(X,Y,Z) =X^Y^ZI(X,Y,Z)=Y^(X|(~Z))#（&amp;；是与，|是或，~是非，^是异或） 这四个函数的说明：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。 F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。 假设Mj表示消息的第j个子分组（从0到15），常数ti是4294967296*abs(sin(i)）的整数部分，i取值从1到64，单位是弧度。（4294967296等于2的32次方） FF(a,b,c,d,Mj,s,ti）表示 a = b + ((a + F(b,c,d) + Mj + ti) &lt;&lt; s) GG(a,b,c,d,Mj,s,ti）表示 a = b + ((a + G(b,c,d) + Mj + ti) &lt;&lt; s) HH(a,b,c,d,Mj,s,ti）表示 a = b + ((a + H(b,c,d) + Mj + ti) &lt;&lt; s) Ⅱ（a,b,c,d,Mj,s,ti）表示 a = b + ((a + I(b,c,d) + Mj + ti) &lt;&lt; s) 这四轮（64步）是： 第一轮 12345678910111213141516FF(a,b,c,d,M0,7,0xd76aa478）FF(d,a,b,c,M1,12,0xe8c7b756）FF(c,d,a,b,M2,17,0x242070db)FF(b,c,d,a,M3,22,0xc1bdceee)FF(a,b,c,d,M4,7,0xf57c0faf)FF(d,a,b,c,M5,12,0x4787c62a)FF(c,d,a,b,M6,17,0xa8304613）FF(b,c,d,a,M7,22,0xfd469501）FF(a,b,c,d,M8,7,0x698098d8）FF(d,a,b,c,M9,12,0x8b44f7af)FF(c,d,a,b,M10,17,0xffff5bb1）FF(b,c,d,a,M11,22,0x895cd7be)FF(a,b,c,d,M12,7,0x6b901122）FF(d,a,b,c,M13,12,0xfd987193）FF(c,d,a,b,M14,17,0xa679438e)FF(b,c,d,a,M15,22,0x49b40821） 第二轮 12345678910111213141516GG(a,b,c,d,M1,5,0xf61e2562）GG(d,a,b,c,M6,9,0xc040b340）GG(c,d,a,b,M11,14,0x265e5a51）GG(b,c,d,a,M0,20,0xe9b6c7aa)GG(a,b,c,d,M5,5,0xd62f105d)GG(d,a,b,c,M10,9,0x02441453）GG(c,d,a,b,M15,14,0xd8a1e681）GG(b,c,d,a,M4,20,0xe7d3fbc8）GG(a,b,c,d,M9,5,0x21e1cde6）GG(d,a,b,c,M14,9,0xc33707d6）GG(c,d,a,b,M3,14,0xf4d50d87）GG(b,c,d,a,M8,20,0x455a14ed)GG(a,b,c,d,M13,5,0xa9e3e905）GG(d,a,b,c,M2,9,0xfcefa3f8）GG(c,d,a,b,M7,14,0x676f02d9）GG(b,c,d,a,M12,20,0x8d2a4c8a) 第三轮 12345678910111213141516HH(a,b,c,d,M5,4,0xfffa3942）HH(d,a,b,c,M8,11,0x8771f681）HH(c,d,a,b,M11,16,0x6d9d6122）HH(b,c,d,a,M14,23,0xfde5380c)HH(a,b,c,d,M1,4,0xa4beea44）HH(d,a,b,c,M4,11,0x4bdecfa9）HH(c,d,a,b,M7,16,0xf6bb4b60）HH(b,c,d,a,M10,23,0xbebfbc70）HH(a,b,c,d,M13,4,0x289b7ec6）HH(d,a,b,c,M0,11,0xeaa127fa)HH(c,d,a,b,M3,16,0xd4ef3085）HH(b,c,d,a,M6,23,0x04881d05）HH(a,b,c,d,M9,4,0xd9d4d039）HH(d,a,b,c,M12,11,0xe6db99e5）HH(c,d,a,b,M15,16,0x1fa27cf8）HH(b,c,d,a,M2,23,0xc4ac5665） 第四轮 12345678910111213141516Ⅱ（a,b,c,d,M0,6,0xf4292244）Ⅱ（d,a,b,c,M7,10,0x432aff97）Ⅱ（c,d,a,b,M14,15,0xab9423a7）Ⅱ（b,c,d,a,M5,21,0xfc93a039）Ⅱ（a,b,c,d,M12,6,0x655b59c3）Ⅱ（d,a,b,c,M3,10,0x8f0ccc92）Ⅱ（c,d,a,b,M10,15,0xffeff47d)Ⅱ（b,c,d,a,M1,21,0x85845dd1）Ⅱ（a,b,c,d,M8,6,0x6fa87e4f)Ⅱ（d,a,b,c,M15,10,0xfe2ce6e0)Ⅱ（c,d,a,b,M6,15,0xa3014314）Ⅱ（b,c,d,a,M13,21,0x4e0811a1）Ⅱ（a,b,c,d,M4,6,0xf7537e82）Ⅱ（d,a,b,c,M11,10,0xbd3af235）Ⅱ（c,d,a,b,M2,15,0x2ad7d2bb)Ⅱ（b,c,d,a,M9,21,0xeb86d391） 所有这些完成之后，将A、B、C、D分别加上a、b、c、d。然后用下一分组数据继续运行算法，最后的输出是A、B、C和D的级联。 当你按照我上面所说的方法实现MD5算法以后，你可以用以下几个信息对你做出来的程序作一个简单的测试，看看程序有没有错误。 12345678MD5 (&quot;&quot;) = d41d8cd98f00b204e9800998ecf8427eMD5 (&quot;a&quot;) = 0cc175b9c0f1b6a831c399e269772661MD5 (&quot;abc&quot;) = 900150983cd24fb0d6963f7d28e17f72MD5 (&quot;message digest&quot;) =f96b697d7cb7938d525a2f31aaf161d0MD5 (&quot;abcdefghijklmnopqrstuvwxyz&quot;) = c3fcd3d76192e4007dfb496cca67e13bMD5 (&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;)=f29939a25efabaef3b87e2cbfe641315","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://0w0suy.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"现代密码之对称算法","slug":"现代密码之对称算法","date":"2021-07-30T05:08:15.000Z","updated":"2021-07-31T02:48:28.247Z","comments":true,"path":"2021/07/30/现代密码之对称算法/","link":"","permalink":"https://0w0suy.github.io/2021/07/30/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E4%B9%8B%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95/","excerpt":"","text":"现代密码学的任务不仅仅只限于传统密码学的“保密通信”，而是含义更广的“信息安全”，其中包括“保密通信”、“数据加密”、“数字签名”等重要的功能。现代密码学已成为信息时代无处不在不可或缺的信息安全卫士。 现代密码学的安全性主要由密钥的设计和使用决定。 按技术特征，现代密码学分为三类： 对称算法、非对称算法、摘要算法 今天主要讲讲对称算法0w0 对称算法 又称传统密码算法、秘密密钥算法或单密钥算法。加密与解密密钥一样的密码算法。该算法又分为序列密码（流密码）算法、分组密码算法 序列密码算法序列密码也称为流密码，它是对称密码算法的一种。序列密码具有实现简单、便于硬件实施、加解密处理速度快、没有或只有有限的错误传播等特点。 在实际应用中，特别是专用或机密机构中保持着优势，典型的应用领域包括无线通信、外交通信。 1949年Shannon证明了只有一次一密的密码体制是绝对安全的，这给序列密码技术的研究以强大的支持，序列密码方案的发展是模仿一次一密系统的尝试。那神马是一次一密呢？ 1、密钥和加密的消息等长 2、密钥由真正随机符号组成 3、密钥只用一次，永不对其他消息复用 这就像在一天的24小时之内，把每个时间点看成一个密钥，每一个密钥一一对应一个时间点，永不复用。 RC4加密RC4原理 1、密钥流：RC4算法关键是依据明文和密钥生成相应的密钥流，密钥流的长度和明文的长度是相同的。假如明文有333字节，那么密钥流也要有333字节。当然，加密生成的密文也是333字节。 2、状态向量S：长度为256，S[0],S[1]…..S[255]。每一个单元都是一个字节，算法执行的不论什么时候。S都包含0-255的8比特数的排列组合，仅仅只是值的位置发生了变换。 3、暂时向量T：长度为256，每一个单元也是一个字节。假如密钥的长度是256，就直接把密钥的值赋给T，否则，轮转地将密钥的每一个字节赋给T 4、密钥K：长度为1-256字节。密钥≠密钥流！二者长度没有必然关系，通常密钥的长度为16字节 柯克霍夫原则Kerckhoffs提出：即使密码系统的任何细节已为人悉知，只要密钥（key）未泄漏，它也应是安全的。 Kerckhoffs准则认为，一个密码系统的安全性不是取决于其算法对于攻击者来说是否保密，而是建立在它所选择的密钥对于攻击者来说是否保密。 实践–使用CrypTool对字符串进行RC4加解密操作 step1：待加密明文 step2：选择RC4加密 step3：选择8bits密钥长度，并点encrypt显示密文 step4：试试24bits密钥长度加密后的密文 –对8bits密钥长度进行穷举攻击 安全研究人员称，现在世界上近三分之一的HTTPS加密连接可被破解，并且效率极高。这种针对RC4加密的破解技术，同样也可以用来破解WiFi数据包。 研究人员很早前就发现可以利用RC4中的统计偏差，导致可对加密信息中的一些伪随机字节能进行猜测，8bits密钥长度加密的密文，几乎可以秒破解，而24bits的密钥长度可能需要几分钟，这就是之前文章所说的“时间复杂度” step1：按RC4分解 step2:8bits长度密钥加密密文 step3：秒破解穷举结果 分组密码算法把明文分成了确定长度的数据块（字节块），用同一密钥和算法加密每一明文块后得到等长的密文块，然后把密文块按顺序组合起来得到密文。反之也可以得到明文。 IDEA加密算法IDEA是International Data Encryption Algorithm的缩写，即国际数据加密算法，广泛的应用在安全电子邮件PGP中。 IDEA加密算法是一个分组长度为64位的分组密码算法，**密钥长度为128位,**同一个算法即可用于加密，也可用于解密。发展IDEA也是因为感到DES具有密钥太短等缺点。IDEA的密钥为128位，这么长的密钥在今后若干年内应该是安全的。这是基于“相异代数群上的混合运算”设计思想，算法运用硬件与软件实现都很容易，而且比DES算法在实现上快的多。IDEA自问世以来，已经经历了大量的详细审查，对密码分析具有很强的抵抗能力，在多种商业产品中被使用。 IDEA加密算法的原理 64-位数据分组被分成4个16-位子分组：xl，X2，x3，x4。 这4个子分组成为算法的第一轮的输入，总共有8轮。 在每一轮中，这4个子分组相列相异或，相加，相乘，且与6个16-位子密钥相异或，相加，相乘。 在轮与轮间，第二和第二个子分组交换。最后在输出变换中4个子分组与4个子密钥进行运算。 以下表述中的相加，指的是：（a + b) mod p，其结果是a+b算术和除以p的余数。例如对于下列表述中的“（2)X2和第二个子密钥相加”就是指用X2与第二个子密钥的和除以2^16(即65536)后的余数。 以下表述中的相乘，指的是：（a × b) mod p，其结果是 a × b算术乘法除以p的余数。例如对于下列表述中的“（1)X1和第一个子密钥相乘。”就是指用X1和第一个子密钥相乘后的积除于(2^16+1)(即65537)后的余数。 异或指的是不进位加法。 (1)X1和第一个子密钥相乘。 (2)X2和第二个子密钥相加。 (3)X3和第三个子密钥相加。 (4)X4和第四个子密钥相乘。 (5)将第（1)步和第（3)步的结果相异或。· (6)将第（2)步和第（4)步的结果相异或。 (7)将第（5)步的结果与第五个子密钥相乘。 (8)将第（6)步和第（7)步的结果相加。 (9)将第（8)步的结果与第六个子密钥相乘。 (10)将第（7)步和第（9)步的结果相加。 (11)将第（1)步和第（9)步的结果相异或。 (12)将第（3)步和第（9)步的结果相异或。 (13)将第（2)步和第（10)步的结果相异或。 (14)将第（4)步和第（10)步的结果相异或。 每一轮的输出是第（11)、（12)、（13)和（14) 步的结果形成的4个子分组。将中间两个分组分组交换（最后一轮除外）后，即为下一轮的输入。 经过8轮运算之后，有一个最终的输出变换： (1) X1和第一个子密钥相乘。 (2) X2和第二个子密钥相加。 (3) X3和第三个子密钥相加。 (4) X4和第四个子密钥相乘。 最后，这4个子分组重新连接到一起产生密文。 DES对称加密算法 DES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法 DES算法就是一个把64位的明文输入块变为64位密文输出块的算法,它所使用的密钥也是64位（其实只使用到了56位，其余8位为奇偶校验位 DES算法的入口参数有三个：Key、Data、Mode。 Key（密钥）：为7个字节共56位，是DES算法的工作密钥（若说密钥为64位，其指的也是56位的秘钥加上8位奇偶校验位，奇偶校验位为第8,16,24,32,40,48,56,64位） Data（数据）：为8个字节64位，是要被加密或被解密的数据 Mode（模式）： 为DES的工作方式,有两种:加密或解密。 DES加密过程 IP置换（初始置换） 初始置换的原理其实很简单，根据一个初始置换表，对照表中的数值，将明文数据相应位置的数据移动到该数据所在的位置即可 现在假设我们按照以下顺序置换 先置换a，在原来1的位置，在置换b，在原来2的位置，以此类推，直到按照上表的顺序全部置换完毕 至此我们便得到了初始置换之后的数据Data=“5XPHzrjb7ZRJBtld91TLDvnf=3VNFxph4WOGyqia6YQI(i)Askc80SKCume+2UMEwog” 12L0 = “5XPHzrjb7ZRJBtld91TLDvnf=3VNFxph”R0 = “4WOGyqia6YQI(i)Askc80SKCume+2UMEwog” 函数f运算我们上面说到的16轮完全相同的运算，指的是运算所使用的函数或者说算法是一样的，但是参数L、R以及K是不相同的，而这是什么相同的运算呢？看下图↓ 从上图我们可以知道，函数f主要对数据的右半部分R进行了操作。下面对这个运算进行一定解释说明 扩展置换E扩展置换的作用对象是我们在初始置换后，将数据拆分为两部分（L,R）中的右半部分R。扩展置换表如下： 中间的4*8组是数据R（32位），左右两列黑色的是扩展时添加的数据。黑32是上一列最后一位蓝32的数据，黑4是上一列最后一位蓝4的数据，以此类推 我们得到上面的 R0=“4WOGyqia6YQI(i)Askc80SKCume+2UMEwog” 分组后扩展： 之后得到48位的R0 “g4WOGYGYqia6a6YQI(i)AI(i)Askc8c80SKCKCume+e+2UMEMEwog4” 子密钥K的生成子秘钥K的生成过程中，又有两次置换，称为压缩置换1和压缩置换2 而循环左移的位数按照下表进行 S盒替换在扩展置换E结束之后，进行K1与R0的异或运算后得到的48位数据压缩为32位数据，S盒一共有8个，每一个都是一个4行16列的数组 我们前面扩展置换后得到的R0是48位的数据，我们的S盒有8个，那么我们就需要将得到的R0平均分为8组，每组对应一个S盒。 每一组的数据长度为6位，假设第一组的二进制数据为：“100110” 那么，我们取第一位与最后一位，组成行数：“10”=2 取中间四位，组成列数：“0011”=3 那么，在对应的S1盒中，取2行3列的数据（第3行第4列）：8 转换为2进制：“1000” 那么就将这个得到的4位二进制数据，代替原来第一组的6位数据，这样一来，等8个S盒全部代替完毕，我们就得到32位的数据。 P盒置换 S盒置换完成之后，要进行的就是P盒置换了，输入32位的数据，得到32位的输出，置换表如下： 至此我们便得到了f(R0,K1),只要再与L0进行异或运算，就得到了第一轮运算最终的R1，然后再将R0的值赋给L1，就完成了第一轮的运算，得到了L1,R1。 末置换经过16次的运算，我们在函数f的最后，会得到L16、R16 然后将L16与R16合并，但是与之前的步骤中的合并不同，此次合并需要先交换二者的位置，也就是应该是R16L16 合并之后我们就得到了长度为64位的数据，在用这64位数据进行末置换，最终得到的数据就是加密后的数据。 传送门DES加解密 AES加密算法高级加密标准（Advanced Encryption Standard ），采用的一种区块加密标准。这个标准用来替代原先的DES。 AES的加密过程是在一个4×4的字节矩阵上运作，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个Byte）。加密时，各轮AES加密循环（除最后一轮外）均包含4个步骤： 1、 字节替代（SubBytes）—透过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。 2、行移位（ShiftRows）—将矩阵中的每个横列进行循环式移位。 3、列混淆（MixColumns）—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey取代。 4、轮密钥加（AddRoundKey）—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。 AES的解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。 下面从网上找了几张图来直观说明 字节代替 行移位在AES中（区块大小128位），第一行维持不变，第二行里的每个字节都向左循环移动一格，第三行里的每个字节都向左循环移动二格，第四行里的每个字节都向左循环移动三格。经过行移位之后，矩阵中每一竖列，都是由输入矩阵中的每个不同列中的元素组成。 列混淆 轮密相加密钥将会与原矩阵合并。在每次的加密循环中，都会由主密钥产生一把回合密钥 密钥扩展","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://0w0suy.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"那些脑洞大开的加密","slug":"那些脑洞大开的加密","date":"2021-07-26T14:54:49.000Z","updated":"2021-07-27T12:18:15.961Z","comments":true,"path":"2021/07/26/那些脑洞大开的加密/","link":"","permalink":"https://0w0suy.github.io/2021/07/26/%E9%82%A3%E4%BA%9B%E8%84%91%E6%B4%9E%E5%A4%A7%E5%BC%80%E7%9A%84%E5%8A%A0%E5%AF%86/","excerpt":"","text":"古典密码可以分为换位加密和替换加密 其中，替换加密可以分为单表替代密码和多表替代 换位加密对明文字符或字符组进行位置移动的密码 明文的字母顺序被打乱了，但明文字母本身不变 栅栏密码(Rail-fence Cipher)栅栏密码是一种简单的移动字符位置的加密方法，规则简单，容易破解 把要加密的明文分成n组，然后把每一组的第2个字符、第2个字符等依次连起来，最后把他们全部连接起来就是密文。栅栏密码又分为传统栅栏和w型栅栏 传统栅栏密码明文 1WEAREDISCOVEREDFLEEATONCE 每组字数为5，按照字数把明文分成： 12345WEAREDISCOVEREDFLEEATONCE 分别取每组第一个字符等连接后 1WDVFTEIELOASRENRCEECEODAE 传统传送门 w型栅栏密码W型栅栏密码加密的方法中，明文由上至下顺序写上，当到达最低部时，再回头向上，一直重复直至整篇明文写完为止 明文 1WEAREDISCOVEREDFLEEATONCE 加密 123W . . . E . . . C . . . R . . . L . . . T . . . E. E . R . D . S . O . E . E . F . E . A . O . C .. . A . . . I . . . V . . . D . . . E . . . N . . 按行读取后的密文： 1WECRLTEERDSOEEFEAOCAIVDEN w型传送门 曲路密码(Curve Cipher)曲路密码(Curve Cipher)是一种换位密码，需要事先双方约定密钥(也就是曲路路径)。 明文 1The quick brown fox jumps over the lazy dog 填入5行7列表(事先约定填充的行列数) 加密的回路线(事先约定填充的行列数) 密文 1gesfc inpho dtmwu qoury zejre hbxva lookT 列移位密码(Columnar Transposition Cipher)列移位密码(Columnar Transposition Cipher)是一种比较简单，易于实现的换位密码，通过一个简单的规则将明文打乱混合成密文。 明文 1The quick brown fox jumps over the lazy dog 密钥 how are u 填入5行7列表(事先约定填充的行列数，如果明文不能填充完表格可以约定使用某个字母进行填充) 密钥： how are u 按how are u在字母表中的出现的先后顺序进行编号，我们就有a为1,e为2，h为3，o为4，r为5，u为6，w为7，所以先写出a列，其次e列，以此类推写出的结果便是密文 密文 1qouryinphotkoolhbxvauwmtdcfsegerjez 行列数相等的填充规则 云影密码该密码又称为01248，使用 0，1，2，4，8 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 例如：18=1+8=9,9对应I 密文： 18842101220480224404014224202480122 采用0分割 188421 122 48 2244 4 142242 248 122 相加数字 123 5 12 12 4 15 14 5 对应字母后的明文 1WELLDONE 替换加密替换密码构造一个或多个密文字母表，然后用密文字母表中的字母或者字母组来代替明文字母或字母组，各字母或字母组的相对位置不变，但其本身的值改变了。 单表替换密码明密文一一对应，因此破解方式单一 在密钥空间较小的情况下，采用暴力破解方式 在密文长度足够长的时候，使用词频分析，http://quipqiup.com/ 凯撒密码(Caesar Cipher)凯撒密码(Caesar Cipher）或凯撒变换、变换加密、位移加密)是一种替换加密，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 明文：The quick brown fox jumps over the lazy dog 偏移量：1 密文：Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph 附上参考表 凯撒(Caesar)枚举 埃特巴什码(Atbash Cipher)埃特巴什码(Atbash Cipher)是一种以字母倒序排列作为特殊密钥的替换加密 12ABCDEFGHIJKLMNOPQRSTUVWXYZZYXWVUTSRQPONMLKJIHGFEDCBA 明文： the quick brown fox jumps over the lazy dog 密文： gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt 传送门 ROT5/13/18/47ROT5/13/18/47是一种简单的码元位置顺序替换暗码。此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取。 R即rotate，旋转，ROT5表示旋转5个位置 ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。 ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。 ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。 ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码 下面以rot13以例。 明文： the quick brown fox jumps over the lazy dog 密文： gur dhvpx oebja sbk whzcf bire gur ynml qbt ROT5、ROT13、ROT18、ROT47位移编码 (qqxiuzi.cn) 简单换位密码(Simple Substitution Cipher)加密方式是以每个明文字母被与之唯一对应且不同的字母替换的方式实现的，它不同于恺撒密码，因为密码字母表的字母不是简单的移位，而是完全是混乱的， 这也使得其破解难度要高于凯撒密码。比如： 12明文字母 : abcdefghijklmnopqrstuvwxyz明文字母 : phqgiumeaylnofdxjkrcvstzwb 明文： the quick brown fox jumps over the lazy dog 密文： cei jvaql hkdtf udz yvoxr dsik cei npbw gdm 由于这种加密方式导致其所有的密钥个数是26!26! ，所以几乎上不可能使用暴力的解决方式。所以我们 一般采用词频分析。 quipqiup - cryptoquip and cryptogram solver 培根密码(Baconian Cipher)每个明文字母被一个由5字符组成的序列替换，最初的加密方式就是由’A’和’B’组成序列替换明文 123456789101112131415A = aaaaa I/J = abaaa R = baaaaB = aaaab K = abaab S = baaabC = aaaba L = ababa T = baabaD = aaabb M = ababb U/V = baabbE = aabaa N = abbaa W = babaaF = aabab O = abbab X = bababG = aabba P = abbba Y = babbaH = aabbb Q = abbbb Z = babbb 明文： T H E F O X 密文： baaba aabbb aabaa aabab abbab babab Baconian Cipher (rumkin.com) 图形替代密码猪圈密码(Pigpen Cipher)或称九宫格密码、朱高密码、共济会密码或共济会员密码 是一种以格子为基础的简单替代式密码 圣堂武士密码(Templar Cipher)是“猪圈密码”的一个变种 会跳舞的小人 仿射密码(Affine Cipher)字母表中的每个字母相应的值使用一个简单的数学函数映射到对应的数值，再把对应数值转换成字母。 每一个字母都是通过函数（ax + b）mod m加密，其中b是位移量，为了保证仿射密码的可逆性，a和m需要满足gcd(a , m)=1，一般m为设置为26。 常见的字母对应关系： 下面我们以E(x) = (5x + 8) mod 26函数为例子 Practical Cryptography 多表替换密码棋盘密码（Checkerboard Cipher)1234567 Q U I C K --------------B |K N I/J G HR |P Q R S TO |O Y Z U AW |M X W V BN |L F E D C 经过密阵替换: 12明文:T H E Q U I C K B R O W N F O X密文:RK BK RU OC OC BI NK BQ WK RI OQ WI BU NU OQ WU 波利比奥斯方阵密码（Polybius Square ）简单的来说就是把字母排列好，用坐标(行列)的形式表现出来。字母是密文，明文便是字母的坐标。 明文：HELLO 密文：2315242434 维吉尼亚密码(Vigenère Cipher)是在单一恺撒密码的基础上扩展出多表代换密码，根据密钥(当密钥长度小于明文长度时可以循环使用)来决定用哪一行的密表来进行替换，以此来对抗字频统计。 明文： THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密钥(循环使用，密钥越长相对破解难度越大)： CULTURE 加密过程：如果第一行为明文字母，第一列为密钥字母，那么明文字母’T’列和密钥字母’C’行的交点就是密文字母’V’，以此类推。 密文： VBP JOZGM VCHQE JQR UNGGW QPPK NYI NUKR XFK Online calculator: Vigenère cipher (planetcalc.com) 博福特密码(Beaufort Cipher)一种类似于维吉尼亚密码的代换密码，博福特密码属于对等加密，即加密演算法与解密演算法相同。 明文： THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密钥(循环使用，密钥越长相对破解难度越大)： CULTURE 加密过程：如果第一行为明文字母，第一列为密文字母，那么沿明文字母’T’列出现密钥字母’C’的行号就是密文字母’J’，以此类推。 密文： JNH DAJCS TUFYE ZOX CZICM OZHC BKA RUMV RDY 滚动密钥密码(Running Key Cipher)和维吉尼亚密码有着相同的加密机制，区别是密钥的选取，维吉尼亚使用的密钥简短，而且重复循环使用，与之相反，滚动密钥密码使用很长的密钥，比如引用一本书作为密钥。这样做的目的是不重复循环使用密钥，使密文更难破译 明文： THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密钥：选取C语言编程(1978版)第63页第1行”errors can occur in several places. A label has…”，去掉非字母部分作为密钥(实际选取的密钥很长，长度至少不小于明文长度)。 加密过程：加密过程和维吉尼亚密码加密过程相同 密文: XYV ELAEK OFQYH WWK BYHTJ OGTC TJI DAK YESR 希尔密码(Hill Cipher)介绍希尔密码是基于线性代数多重代换密码。每个字母转换成26进制数字：A=0, B=1, C=2…Z=25一串字母当成n维向量，跟一个n×n的矩阵（密钥）相乘，再将得出的结果MOD26。 加密明文：ACT 对应：0，2,19 密钥：GYBNQKURP 对应：6,24,1,13,16,10,20，17,15 加密矩阵： 把加密矩阵左乘明文对应矩阵 密文： 15,14,7分别对应POH 普莱菲尔密码（playfair）是第一种用于实际的双字替换密码，用双字加密取代了简单代换密码的单字加密，很明显这样使得密文更难破译，因为使用简单替换密码的频率分析基本没有什么作用，虽然频率分析，通常仍然可以进行，但是有25×25=625种可能而不是25种可能 以明文THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 和密钥 CULTURE 为例 编制密码表整理密钥字母 C U L T U R E ，去掉后面重复的字母得到： C U L T R E 用上一步得到的字母自上而下来填补5乘5方表的纵列（也可横排），之后的空白按照相同的顺序用字母表中剩余的字母依次填补完整，得到如下的方格: 这一步需要注意的要点：整理密钥字母时，如果出现”Z”，则需要去除，因为在英文里”Z”的使用频率最低，相应的如果是德文，则需将”I”与”J”当作一个字母来看待，而法语则去掉”W”或”K” 整理明文 原则是“两个一组”，得到是若干个两两成对的字母段 将明文两两一组按顺序排开，得到： TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO G 2.对于末尾的单个字母要加上一个” X “使之成对： TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO GX 这一步需要注意的要点：对于相连字母相同者，每个后面都需要加” X “，例如 TOMORROW ，需要写成： TO MO RX RX OW 。 编写密文 1.如果两个字母在同一行则要用它右邻的字母替换，如果已在最右边，则用该行最左边的替换，如明文为” CE “，依据上表，应替换为” EG “； 2.如果两个字母在同一列则要用它下边的字母替换，如果已在最下边，则用该行最上边的替换，如明文为” OQ “，依据上表，应替换为” PS “； 3.如果两个字母在不同的行或列，则应在密码表中找两个字母使四个字母组成一个矩形，明文占据两个顶点，需用另外两个顶点的字母替换，如明文为” HX “，可以替换为” WI/J “或” I/JW “（下面的例子将按照横向替换原则即同行优先）。 按照上述原则，将明文 TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO GX 加以转换得到 KU ND LH GT LF WU ES PW LH SI/J NP CG CR AG BU VZ QA I/JV 将得到的字母改为大写并五个一组列好，得到密文 KUNDL HGTLF WUESP WLHSI NPCGC RAGBU VZQAI V Practical Cryptography","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://0w0suy.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"编码入门总结","slug":"编码入门总结","date":"2021-07-25T09:17:05.000Z","updated":"2021-07-25T15:14:16.564Z","comments":true,"path":"2021/07/25/编码入门总结/","link":"","permalink":"https://0w0suy.github.io/2021/07/25/%E7%BC%96%E7%A0%81%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"前言编码–隐匿在计算机背后的语言。在计算机眼里读到的所有文字都是由0和1组成的字符串，为了能让汉字正常显示在屏幕上，我们需要做以下两件事情： 1、给所有的汉字一个独一无二的数字编号，做一个数字编号到汉字的mapping关系（即字符集）2、把这个数字编号能用0和1表示出来 第2件事情并不是直接把数字编号用二进制表示出来那么简单，还要处理多个字连在一起的时候如何做分隔的问题。第2件事情通常解决方案要么就是规定好每个字长度（例如所有文字都是2bytes，不够的前面用0补齐），要么就是在用0和1表示的时候，不仅需要表示出数字编码，还要暗示给计算机接下来多少个连续byte构成一个字。 进入编码定义编码是信息从一种形式或格式转换为另一种形式的过程。解码，是编码的逆过程。 关系这是几种常见的中文编码之间的兼容性（子集=同时存在也不冲突=不会出现乱 从中我们可以看到ASCLL的兼容性是最好的，而UTF-8与它部分没有交集，这也是平常会出现乱码的原因。 分类ASCLL编码ASCII编码每个字母或符号占1byte（8bits），并且8bits的最高位是0。通常所说的标准ASCII只有前128个值！（2^7=128) ASCLL非打印控制字符ASCII表上的数字0–31分配给了控制字符，用于控制像打印机等一些外围设备。例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。 ASCLL打印字符数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。 扩展ASCLL打印字符扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0–32显示在下图中），又增加了128个字符，总共是256个。 GB系列编码GB全称GuoBiao国标，GBK全称GuoBiaoKuozhan国标扩展。GB18030编码兼容GBK，GBK兼容GB2312。 GB2312最早一版的中文编码，每个字占据2bytes。由于要和ASCII兼容，那这2bytes最高位不可以为0了（否则和ASCII会有冲突）。在GB2312中收录了6763个汉字以及682个特殊符号，已经囊括了生活中最常用的所有汉字。 GB2312编码表有个值得注意的点，这个表中也有一些数字和字母，与ASCII里面的字母非常像。例如A3B2对应的是数字2，但是ASCII里面50（十进制）对应的也是数字2。他们的区别就是输入法中所说的“半角”和“全角”。全角的数字2占两个字节。 通常，我们在打字或编程中都使用半角，即ASCII来编写数字或英文字母。 GBK由于GB2312只有6763个汉字，我汉语博大精深，只有6763个字怎么够？于是GBK中在保证不和GB2312、ASCII冲突（即兼容GB2312和ASCII）的前提下，也用每个字占据2bytes的方式又编码了许多汉字。经过GBK编码后，可以表示的汉字达到了20902个，另有984个汉语标点符号、部首等。值得注意的是这20902个汉字还包含了繁体字 GB18030然而，GBK的两万多字也已经无法满足我们的需求了，还有更多可能你自己从来没见过的汉字需要编码。 这时候显然只用2bytes表示一个字已经不够用了（2bytes最多只有65536种组合，然而为了和ASCII兼容，最高位不能为0就已经直接淘汰了一半的组合，只剩下3万多种组合无法满足全部汉字要求）。因此GB18030多出来的汉字使用4bytes编码。当然，为了兼容GBK，这个四字节的前两位显然不能与GBK冲突 值得一提，实际中GB18030很少提到，通常GBK见得比较多，这是因为如果你去看一下GB18030里面所编码的文字，你会发现自己一个字也不认识…… Unicode编码Unicode是一种字符集标准，最常见的unicode字符编码是UTF-8 UTF-8与前面说的GB系列编码不兼容，所以如果一个文件中即有UTF-8编码的文字，又有GB18030编码的文字，那绝对会有乱码。 Unicode赋予了全世界所有文字和符号一个独一无二的数字编号，UTF-8所做的事情就是把这个数字编号表示出来（要处理多个字连在一起的时候如何做分隔的问题 UTF-8解决字符间分隔的方式是数二进制中最高位连续1的个数来决定这个字是几字节编码。0开头的属于单字节，和ASCII码重合，做到了兼容。 上表中标注X的位置才是真正用来表示Unicode数值的。 对于中文汉字来说，所有常用汉字的Unicode值都可以用3字节的UTF8表示出来，而GBK编码的汉字基本是2字节（GB18030虽4字节但是日常没人会写那些字）。这也就导致了，如果把GBK编码的中文文本另存为UTF8编码，体积会大50%左右。这也是UTF8的一点小瑕疵，存储同样的汉字，体积比GBK要大50%。 不过在“可表示世界上所有文字”这一巨大优势面前，UTF8的这点小瑕疵可以忽略了，所以日常开发中最常使用UTF8。 base家族base64特点：a-z A-Z 0-9 + / ==补位 用途：编码邮件内容、网页图片 原理：Base64将输入字符串按字节切分，取得每个字节对应的二进制值（若不足8比特则高位补0），然后将这些二进制数值串联起来，再按照6比特一组进行切分（因为2^6=64），最后一组若不足6比特则末尾补0。将每组二进制值转换成十进制，然后在表格中找到对应的符号并串联起来就是Base64编码结果。 由于二进制数据是按照8比特一组进行传输，因此Base64按照6比特一组切分的二进制数据必须是24比特的倍数（6和8的最小公倍数）。24比特就是3个字节，若原字节序列数据长度不是3的倍数时且剩下1个输入数据，则在编码结果后加2个=；若剩下2个输入数据，则在编码结果后加1个=。 Base64编码转换工具，Base64加密解密 (qqxiuzi.cn) base32特点：A-Z 2-7 ==补位,不区分大小写，避免了1，8,0与I,B,O的混淆 用途：一些对大小写不敏感的文件系统 原理：Base32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个。 由于数据的二进制传输是按照8比特一组进行（即一个字节），因此Base32按5比特切分的二进制数据必须是40比特的倍数（5和8的最小公倍数）。例如输入单字节字符“%”，它对应的二进制值是“100101”，前面补两个0变成“00100101”（二进制值不足8比特的都要在高位加0直到8比特），从左侧开始按照5比特切分成两组：“00100”和“101”，后一组不足5比特，则在末尾填充0直到5比特，变成“00100”和“10100”，这两组二进制数分别转换成十进制数，通过上述表格即可找到其对应的可打印字符“E”和“U”，但是这里只用到两组共10比特，还差30比特达到40比特，按照5比特一组还需6组，则在末尾填充6个“=”。 Base32编码解码，Base32在线转换工具 - 千千秀字 (qqxiuzi.cn) base16特点：非常接近hex(base16是大写，然后hex是小写，其余不变） 原理：Base16先获取输入字符串每个字节的二进制值（不足8比特在高位补0），然后将其串联进来，再按照4比特一组进行切分，将每组二进制数分别转换成十进制，在下述表格中找到对应的编码串接起来就是Base16编码。可以看到8比特数据按照4比特切分刚好是两组，所以Base16不可能用到填充符号“=”。 Base16编码后的数据量是原数据的两倍：1000比特数据需要250个字符（即 250*8=2000 比特）。换句话说：Base16使用两个ASCII字符去编码原数据中的一个字节数据。 Base16编码解码，Base16在线转换工具 - 千千秀字 (qqxiuzi.cn) hex特点：用0-9，A-F表示这16种情况。（十六进制 原理：编码时，将8位二进制码重新分组成两个4位的字节（8位=1字节，其中一个字节的低4位是原字节的高4位，另一个字节的低4位是原字节的低4位，其他都补0，然后输出这两个字节对应十六进制数字作为编码。 结果：Hex编码后的长度是源数据的2倍 ASCII码： A (65) 二进制码：0100_0001 重新分组：0000_0100 0000_0001 十六进制： 4 1 Hex编码：41 HTML编码特点：以&amp;开头，以；结尾 用途：在HTML文件中，是HTML编写过程中使用特殊的编码字符来进行网页页面的正确显示，是网页上面的一种编码格式。 12编码前：&amp;编码后：&amp;amp; urlencode特点：有%（又叫百分号编码 用途：构造反序列化对象、sql注入绕过、文件包含绕过 CTF在线工具-在线URL编码|URL解码 (ssleye.com) 12编码前：欢迎来到我的博客编码后：%E6%AC%A2%E9%A5%AE%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2 morsecode特点：由.和-组成的代码，中间以空格或者/间隔 CTF在线工具-在线莫尔斯电码编码|在线莫尔斯电码解码|莫尔斯电码算法|Morse (ssleye.com) 12编码前：欢迎来到我的博客编码后：--.-.--..-...-. -...------..---. --..---.--..-.- -.-..-...--.... --...-....-...- ---.--.-....-.. -.-..--.-.--.-. -.--.---.-...-. 摩尔斯电码字母和数字对应表： jsfuck特点：仅含有+[]!() 用途：书写JavaScript代码 http://codertab.com/JsUnFuck shellcode编码Quoted-printable编码特点：任何一个8位的字节值可编码为3个字符–一个等号”=”后跟随两个十六进制数字(0–9或A–F)表示该字节的数值。 Quoted-printable 可译为“可打印字符引用编码”、“使用可打印字符的编码”，我们收邮件，查看信件原始信息，经常会看到这种类型的编码！它是多用途互联网邮件扩展（MIME) 一种实现方式。其中MIME是一个互联网标准，它扩展了电子邮件标准，致力于使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息。目前http协议中，很多采用MIME框架！quoted-printable 就是说用一些可打印常用字符，表示一个字节（8位）中所有非打印字符方法。 12编码前：欢迎来到我的博客编码后：=E6=AC=A2=E8=BF=8E=E6=9D=A5=E5=88=B0=E6=88=91=E7=9A=84=E5=8D=9A=E5=AE=A2 网络管理员在线工具 - Quoted-Printable (mxcz.net) XXencode编码特点：64个字符，跟base64打印字符相比，就是UUencode多一个“-” 字符，少一个”/” 字符。 原理：XXencode将输入文本以每三个字节为单位进行编码。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6bit为单位分为4个组，每个组以十进制来表示所出现的数值只会落在0到63之间。以所对应值的位置字符代替。它所选择的可打印字符是：+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz，一共64个字符。 在线XXencode编码|在线XXencode解码|XX编码|XX解码|XXencode编码原理介绍–查错网 (chacuo.net) uuencode特点：不含小写字母 UUencode是一种二进制到文字的编码，最早在unix 邮件系统中使用，全称：Unix-to-Unix encoding 原理：UUencode将输入文本以每3个字节为单位进行编码，如果最后剩下的资料少于三个字节，不够的部份用零补齐。三个字节共有24个Bit，以6-bit为单位分为4个组，每个组以十进制来表示所出现的字节的数值。这个数值只会落在0到63之间。然后将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。 12编码前：欢迎来到我的博客编码后：9YJRBZ:6NYIVEY8BPYHB1YYJ$Y8V:Y:ZB&quot;@ Escape/Unescape特点：%u 原理：Escape/Unescape加密解码/编码解码,又叫%u编码，采用UTF-16BE模式。 Escape编码/加密,就是字符对应UTF-16，16进制表示方式前面加%u。Unescape解码/解密，就是去掉”%u”后，将16进制字符还原后，由utf-16转码到自己目标字符。 中文电码特点:四个字符为一组 中文电码查询 Chinese Commercial Code - 标准电报码免费在线查询|姓名电码|美国签证电码 (mcdvisa.com) 新月佛论禅特点：新佛曰 新约佛论禅/佛曰加密 - PcMoe! 12编码前：欢迎来到我的博客编码后：新佛曰：諳諸隸僧降吽諸陀諳摩隸諳僧缽諳薩諳嚤降斯波諳兜眾哆諳嘇嘚隸嘇羅諳伏哆兜嚴所諳喼若諳陀夷兜諳宣菩諳隸嘇嚴諳吽嘇心須諳祗喃諳羅嚴塞諳如如囑囑諳 生僻字特点：生僻看不懂 汉字拼音在线转换，输入汉字查看拼音（小写、大写、首字母大写；标注声调，多音字识别） (qqxiuzi.cn) 12编码前：淛匶襫黼瀬鎶编码后：这就是flag 社会主义核心价值观编码特点：爱过主义文明和谐等24字 社会主义核心价值观编码器 · 在线工具 - VIP (atool.vip) 12编码前：欢迎你编码后：诚信自由公正友善自由诚信文明友善自由文明友善爱国爱国友善平等诚信平等爱国诚信自由诚信自由自由诚信民主友善法治友善自由富强","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://0w0suy.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"RSA公钥文件解密的分析","slug":"RSA公钥文件解密的分析","date":"2021-07-24T08:48:51.000Z","updated":"2021-07-30T01:03:44.092Z","comments":true,"path":"2021/07/24/RSA公钥文件解密的分析/","link":"","permalink":"https://0w0suy.github.io/2021/07/24/RSA%E5%85%AC%E9%92%A5%E6%96%87%E4%BB%B6%E8%A7%A3%E5%AF%86%E7%9A%84%E5%88%86%E6%9E%90/","excerpt":"","text":"前言今天，手一抽打开了这个网站并注册登录 （一个早上看奥运会碌碌无为 我想就顺便试试水吧） 先做的是easy_RSA,已经把d算出来了，可是提交显示不对..仔细看了题目的要求后..说：flag格式为cyberpeace{小写的你解出的答案}。我以为这是把答案转化成cyberpeace格式…上网搜索“在线cyberpeace转化”未果，才知道原来答案要带上这一串英文啊.. 然后，我又手一抽，点到了下一题..然鹅计时已经开始 啊？都是乱码，没有n,e,c咋解呢这 于是乎，复制了BEGIN PRIVATE KEY到浏览器搜索，顺其自然地开始了我对rsa公钥文件解密的study（ 解密提n，e这时候我们有如下的publickey.pem文件： —–BEGIN PUBLIC KEY—–MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=—–END PUBLIC KEY—– 现在我们需要做的就是从这段字符串中提出n和e pem后缀OpenSSL 使用 PEM 文件格式存储证书和密钥。PEM 实质上是 Base64 编码的二进制内容，再加上开始和结束行，如证书文件的： 123-----BEGIN CERTIFICATE-----``-----END CERTIFICATE----- 在这些标记外面可以有额外的信息，如编码内容的文字表示。文件是 ASCII 的，可以用任何文本编辑程序打开它们。 简单来讲，pem文件这种格式就是用于ASCII(Base64)编码的各种X.509 v3 证书。所以我们用base64解码 base64编码从一个表格中了解base64的发展 名称 缺点 特点 二进制 长 简单，0和1 Hex（16进制 不好表示文本 ASCLL码 只能表示英文 包含字符多 UTF-8 乱码 兼容各种语言 Base-64 国际化 用base64解码： 解出来是一段乱码，旁边有个可以以15进制显示的选项，我们试一下 发现结尾是”\\x01\\x00\\x01”,猜测e=10001 再看看解码后的长度为162,我们找到偏移表,发现模数的偏移位置是159，长度是3,加起来正好162~那么说明这段字符串就是指数和模数加密过后的结果。 解e和n123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-import base64def str2key(s): # 对字符串解码 b_str = base64.b64decode(s) if len(b_str) &lt; 162: return False hex_str = &#x27;&#x27; # 按位转换成16进制 for x in b_str: h = hex(ord(x))[2:] h = h.rjust(2, &#x27;0&#x27;) hex_str += h # 找到模数和指数的开头结束位置 m_start = 29 * 2 e_start = 159 * 2 m_len = 128 * 2 e_len = 3 * 2 modulus = hex_str[m_start:m_start + m_len] exponent = hex_str[e_start:e_start + e_len] return modulus,exponentif __name__ == &quot;__main__&quot;: pubkey = &quot;MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=&quot; key = str2key(pubkey) print key 结果如下： 1(&#x27;C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD&#x27;, &#x27;010001&#x27;) 这个即为我们求出来模数N和指数e 网上说可以用虚拟机Kali Linux直接用命令 1openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem 试了下，确实很方便 我们把n=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD，e=10001（十六进制）在线转化十进制 进制转换 - 在线工具 (tool.lu) 所以e=65537``n=87924348264132406875276140514499937145050893665602592992418171647042491658461 得到n，e后就是常规的做题啦 分解n得pq解码网址上篇也有用到http://www.factordb.com/ p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239 求d走个Python执行结果 1234567import gmpy2 p= gmpy2.mpz(275127860351348928173285174381581152299) q= gmpy2.mpz(319576316814478949870590164193048041239)e= gmpy2.mpz(65537)phi_n= (p-1)*(q-1) d = gmpy2.invert(e,phi_n) print(&quot;d is:\\n%s&quot;%d) 结果d=10866948760844599168252082612378495977388271279679231539839049698621994994673 求m123456789101112131415import gmpy2import rsa e=65537n=87924348264132406875276140514499937145050893665602592992418171647042491658461p=275127860351348928173285174381581152299q=319576316814478949870590164193048041239d=10866948760844599168252082612378495977388271279679231539839049698621994994673key=rsa.PrivateKey(n,e,int(d),p,q) with open(r&quot;C:\\Users\\Lenovo\\Desktop\\0eaf8d6c-3fe5-4549-9e81-94ac42535e7b\\flag.enc&quot;,&quot;rb&quot;)as f: f=f.read() print(rsa.decrypt(f,key)) 总结给出的文件不一定直接给出数字，有时候需要先解码（像这题），提取关键字眼，间接求数字。 有时Python比虚拟机操作繁琐。 一些编码的类型要识别出来（比如base64，hex） 能直接利用网站在线求解的不需要写Python","categories":[{"name":"实例","slug":"实例","permalink":"https://0w0suy.github.io/categories/%E5%AE%9E%E4%BE%8B/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://0w0suy.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"RSA密码的深入浅出","slug":"RSA密码的深入浅出","date":"2021-07-23T01:10:13.000Z","updated":"2021-07-23T14:16:34.044Z","comments":true,"path":"2021/07/23/RSA密码的深入浅出/","link":"","permalink":"https://0w0suy.github.io/2021/07/23/RSA%E5%AF%86%E7%A0%81%E7%9A%84%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/","excerpt":"","text":"昨天看到这样一句话 “密码本质上就是拉开了时间复杂度的差距。” 初次看到，茫然不知，我想，密码跟时间复杂度究竟有何联系？何为复杂度？这复杂程度的参照物又是什么？怀揣着疑问，我在知乎、CSDN上阅读几篇大佬对密码学的认识与理解。阅读归阅读，还是得靠吸收与总结，那现在就开始我对密码学cryptography中RSA的深入浅出吧！（密码学的背景发展史等，网上千篇一律，暂不赘述 时间复杂度先说说开头提到的这句哈把“密码本质上就是拉开了时间复杂度的差距。”我们知道，计算机的计算运行速度很快，四位数乘四位数的计算，人需要一分钟左右，而计算机秒出结果。然而，计算机的计算能力是有限的，就算是超级计算机“天问二号”，计算速度也有上限 所以对于计算机来说，我们需要利用时间复杂度来衡量一个程序的算法有多耗时。按照初中学过的知识，我们知道底数大于1的指数呈“爆炸式增长”，也从古代国王在64个格子放米的例子中可以看出，当放到第28格的时候，需要米已经超过1亿，放到第64格的时候，大约要放92亿粒！（有人计算过，大约是2814亿吨重）从这个例子我们就可以看到，时间复杂度直接影响了程序完成的速度。当计算机计算指数函数10的n次方时，可能就需要好几十年 从而可知，在密码学中，很多时候密码不是不可以破解的，只不过破解密码需要大量的时间。 比如在RSA中最关键的一步，是Alice生成两个指数p和q，计算它们乘积n=p*q，然后告诉Bob这个n的值，他就需要把n质因数分解为p和q，对于这种单项函数来说，逆着运算（即分解质因数)的时间复杂度是指数级，比顺着运算（乘积n）的运算时间来得要长。 假如Alice的这个p和q足够大，等Bob分解完n，恐怕就过去了好几十年。 因此，密码的本质上就是拉开了时间复杂度的差距，使得解密密码的时间复杂度高于加密的时间复杂度，以达成保密的目的。 一些数论来，先来膜拜一下伟大的数学家–欧拉 被称为“对世界数学的发展作出创造性工作的人士”，他值得！ 下述的一些数论知识在初高中就有学习过，简单提一哈~ 欧拉函数–φ（n）φ（n）：在[0,n)中与n互质的正整数的个数 eg：n=23，在[0,23)中，与21互质的正整数有：1、 2、 4 、5 、8、 10、 11 、13、 16 、17、 19、 20这12个数，因此φ（23）=12 φ（n）=（p-1）（q-1） eg：23=7*3，φ（23）=（7-1）（3-1）=12 同余式我们学过余数，同余式就是另外一种写法罢了，下面以一个表格做出比较 名称 余式 同余式 eg1 23÷7=3…2 23≡2（mod7） eg2 50÷8=6…2 50≡2（mod8） 通式 a÷m=k…b a≡b（mod m） 之前学习同余式可能忽略了几个性质，网上找了一下基本性质，直接放图 欧拉公式若a与n互质，则a^φ（n）^≡1（mod n） 乘法逆元如果ab ≡ 1（mod m），则称a和b为关于m互为乘法逆元 已知a求b的方法：因为ab ≡ 1（mod m），所以不妨设ab+mk=1，其中a和m为已知数。可以利用扩展欧几里得算法，计算出来一个乘法逆元b。 RSA简介前面铺垫了这么这么多，终于开始进入咱们的正题–RSA的深入浅出 先对rsa密钥体制做个介绍 1、选择两个大的互质参数p，q，计算出模数n=p*q 2、计算欧拉函数φ（n）=（p-1)(q-1)。选择一个e（1&lt;e&lt;φ（n)),要求e和φ（n）互质，即gcd(e,φ（n）)=1 3、计算e的模反数d。计算方法为e*d≡1（mod φ（n））【模反元素：如果存在两个正整数e和φ（n）互质，那么一定存在一个整数d，使得ed-1被φ（n）整除，即ed=kφ（n）+1.这是，d就是e的模反元素。欧拉公式可以证明模反元素必然存在。两个整数a，b，它们除以整数φ（n）所得余数相等，即a≡1(modφ（n）)，b≡1（modφ（n）），根据相乘的性质ab≡1（modφ（n）），所以a和b互为逆元 4、对明文m加密。密文c=pow（m，e，n），等同于c=m^e^（mod n） 5、对密文c解密。明文m=pow（c，d，n），等同于m=c^d^（mod n） RSA安全性分析值得一提的是，虽然公钥（n，e）是直接公开的，但是只有Alice知道密钥（n，d），可以计算m=c^d^（mod n），除了Alice，没有任何人可以知道φ(n)，所以没有人可以求出e关于φ(n)的乘法逆元d。也就是说d的值从头到尾只有Alice自己知道，不可能泄露。假如Alice把本地的私钥弄丢了，那，谁也解不开密码，这就是非对称密码rsa与对称密码的本质区别 常用的攻击方法直接分解模数基本原理直接分解数模n是最直接的攻击放方法，也是最困难的办法。破解RSA最直接（暴力）的方法就是分解整数n，然后计算欧拉函数φ(n)=(p-1) * (q-1),再通过d * e ≡ 1 mod φ(N)，即可计算出 d，然后就可以使用私钥(N, d)通过m = pow(c,d,N)解密明文。 如果n小于256bit，可以使用本地工具进行暴力分解，例如windwods平台的RSATool，可以在数分钟之内完成256bit的n的分解。如果n大于768bit，可以尝试利用在线网站http://factordb.com， 这一类在线网站的原理是储存了部分n分解成功的的值。 CTF原题12345678910111213141516171819202122232425262728293031323334353637383940&#123;920139713,19&#125;70479679275221115227470416418414022368270835483295235263072905459788476483295235459788476663551792475206804459788476428313374475206804459788476425392137704796792458265677341524652483295235534149509425392137428313374425392137341524652458265677263072905483295235828509797341524652425392137475206804428313374483295235475206804459788476306220148 分解n可以通过在线网站http://www.factordb.com/index.php。 p=18443,q=49891,e=19,c=这一大串数字密文 因此可以通过d * e ≡ 1 mod φ(n)，计算出 d 12345678import gmpy2p = gmpy2.mpz(18443) #初始化大整数q = gmpy2.mpz(49891)e = gmpy2.mpz(19)phi_n = (p-1)*(q-1)d = gmpy2.invert(e,phi_n) #invert（e， φ(n)）返回d使得e*d == 1 mod φ(n)，如果不存在d，则返回0print(&quot;p=%s,q=%s,e=%s&quot;%(p,q,e))print(&quot;d is:\\n%s&quot;%d) 1234#输出结果为p=18443,q=49891,e=19 d is: 96849619 到目前为止，有了d就可以求出明文m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#求明文import gmpy2n = 920139713d = 96849619c = &quot;&quot;&quot;70479679275221115227470416418414022368270835483295235263072905459788476483295235459788476663551792475206804459788476428313374475206804459788476425392137704796792458265677341524652483295235534149509425392137428313374425392137341524652458265677263072905483295235828509797341524652425392137475206804428313374483295235475206804459788476306220148&quot;&quot;&quot;result = &quot;&quot;c_list = c.split()#print(c_list)for i in c_list: result += chr(pow(int(i),d,n))print(result) 对rsa的公共模数攻击使用相同的模数n，取不同的e1、e2，用不同的私钥d1、d2加密同一份明文消息，得到不同的密文c1、c2 基本原理假如采用两个或者两个以上的公钥(n，e)来加密同一条信息，可以得到下面的结论： c1 = pow(m, e1, n)c2 = pow(m, e2, n) 分别拿对应的私钥来加密，可以得到相同的明文m m = pow(c1, d1, n)m = pow(c2, d2, n) 假设攻击者已知n,e1,e2,c1,c2，即可以得到明文m，因为e1和e2互质，所以使用欧几里得算法（用于计算两个整数a,b的最大公约数）可以找到能够满足以下条件的x，y： pow(x,e1)+pow(y,e2)=1 假设x为负数，需再使用欧几里得算法来计算 pow(c1,-1) 则可以得到 pow(pow(c1,-1),-x) * pow(c2,y) = p mod(n) 如果p&lt;n，则p可以被计算出来。 rsa小指数e攻击如果RSA系统的公钥e选取较小的值，比如e=3，就容易受到攻击。 有三个分别使用不同的模数n1,n2,n3，但是都选取e=3，加密同一个明文可以得到： c1 = pow(m,3,n1)c2 = pow(m,3,n2)c3 = pow(m,3,n3) 一般情况下，n1,n2,n3互素，否则会比较容易求出公因子，从而安全性大幅度的减低。 ras选择密文攻击在此种攻击模型中，攻击者需要掌握的内容包括：加密算法、截获的部分密文、自己选择的密文消息以及相应的被解密的明文。 利用公约数思路如果两次加密的n1和n2具有相同的素因子，可以利用欧几里德算法直接分解n1和n2，通过欧几里德算法计算出两个n的最大公约数p 123456789101112def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = tempdef gcd_digui(a, b): if b != 0: return a return gcd(b,a%b)p = gcd(n1,n2) 识别识别此类题目，通常会发现题目给了若干个n，均不相同，并且都是2048bit，4096bit级别，无法正面硬杠，并且明文都没什么联系，e也一般取65537。 例题 n1=9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327n2=13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743 我们用欧几里得算法计算出n1n2的最大公约数p: p=1564859779720039565508870182569324208117555667917997801104862601098933699462849007879184203051278194180664616470669559575370868384820368930104560074538872199213236203822337186927275879139590248731148622362880471439310489228147093224418374555428793546002109 在求出 q1=5783913729972247946253435353096326443704028481940849421114868598345923360618656121534285508526073359609714402851036717793499213802965059543550823534771936528992718924827788759885479930993068821959532735506613731118802093419664455101954524961474681210142720 q2=8451842502173444137736814762941916058188287492225312470701776645749560167356046185751987142378046260660654109657367986531032438683223878564614629060680414105738103196373377352503582154146395466843322435064918174001568589071204760456484430101336520922543227 有了p、q、n、e，再用常规的方法求出d d is:765380157716548443425596742911266886410191216178112356262846713847378783683172254263632491551899451289816619131919308216828436088806741843938280790265785398475478529787399443730855951368875915938248660455496573500895189591415557910142785245074081094025796970799530756594690014890734289131423703767389303315127407756913225666969130239449802975261679436688682166951981930860230211054980705709388431034038355036001994657320535672433358165972446575669374989675751263007447610176671622049636459417182325418702702105 感叹一下，数字真的好大！ Coppersmith定理攻击在一个e阶的mod n多项式f(x)中，如果有一个根小于n^frac&#123;1&#125;&#123;e&#125; ，就可以运用一个O(log n)的算法求出这些根。 这个定理可以应用于RSA算法。如果e = 3并且在明文当中只有三分之二的bite是已知的，这种算法可以求出明文中所有的bite 工具之在线分解大素数：http://factordb.com CTF-RSA-tool: https://github.com/D001UM3/CTF-RSA-tool 参考文章：https://blog.csdn.net/huanghelouzi/article/details/82943615 安装gmpy2：https://blog.51cto.com/u_12332766/2116615 sagemath:http://www.sagemath.org/ (我还没装，暂时没用上)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://0w0suy.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"Python之函数","slug":"Python之函数","date":"2021-07-21T13:02:14.000Z","updated":"2021-07-21T15:31:17.153Z","comments":true,"path":"2021/07/21/Python之函数/","link":"","permalink":"https://0w0suy.github.io/2021/07/21/Python%E4%B9%8B%E5%87%BD%E6%95%B0/","excerpt":"","text":"前言人的细胞数量，约有37兆2千亿个。细胞们在你的身体的世界中，无休无眠地在工作着。趁热打铁，二话不多说开始进入函数之旅叭。其中，函数的参数及返回值是重点。 函数什么是函数函数就是对实现某一特定功能的代码的封装。这样做的好处是：函数能提高应用的模块性和代码的重复利用率。 打个简单的比喻，我们进店买喜茶、海底捞的时候，需要排队、点单、等待、买单等待繁琐的过程，但是通过食用市面上出售的瓶装喜茶、桶装海底捞，就能省去这些步骤，而后者就是封装。 举个栗子!就拿我们平常看到的验证码来说，这就是一个封装函数。直接调用函数名就可以生成n位随机数嗷（ 1234567891011import randomdef validate_code(n): s= &#x27;qwertyuiopasdfghjklzxcvbnm1234567890&#x27; #验证码通常是26个英文字母加上10个数字组成 code = &#x27;&#x27; for i in range(n): r=random.choice(s) code += r print(&#x27;验证码是：&#123;&#125;&#x27;.format(code))validate_code(4)validate_code(5)validate_code(6) 输出结果如图 定义函数123def 函数名([输入参数])： 函数体 [return xxx] 注意： 1、英文字符以及冒号别遗忘（我经常忘冒号低级错误！ 2、函数名要见名知意 3、参数之间用逗号隔开 4、函数体是实现函数功能的代码段，要tab缩进 5、return返回值，有时可以不写，下文介绍 函数调用调用函数也就是执行函数。即把刚才定义的函数当成是一个工具，那么调用函数就相当于使用该工具。即函数名是调用函数的名称。很好理解，暂不赘述。 函数的参数默认值参数默认值是指在定义的时候就给定值，暂不赘述 形式参数在定义函数时，函数名后面括号中的参数就是形式参数 12345def fun1(a,b,c): #abd是在函数定义括号内，为形参 print(&#x27;a=&#x27;,a) print(&#x27;b=&#x27;,b) print(&#x27;c=&#x27;,c)fun1(10,20,30) 位置实参指的是必须按照正确的顺序将实际参数传到函数中 12345def fun1(a,b,c): #abd是在函数定义括号内，为形参 print(&#x27;a=&#x27;,a) print(&#x27;b=&#x27;,b) print(&#x27;c=&#x27;,c)fun1(10,20,30) # 依次将10赋给a，20赋给b，30赋给c。调用函数时传入的实参的数量和位置都必须和定义函数时保持一致。 1234#输出结果为a= 10b= 20c= 30 关键字实参能在调用的时候更加明确参数值是给谁的，因此不再需要与形参的位置完全一致，只要将参数名写正确即可。 123456def fun1(a,b,c): print(&#x27;a=&#x27;,a) print(&#x27;b=&#x27;,b) print(&#x27;c=&#x27;,c)fun1(10,20,30)fun1(a=100,c=2000,b=3000)#与位置形参相比，位置可以不用一一对应 1234#输出结果为a= 100b= 3000c= 2000 可变参数指在定义或者调用的时候不能明确参数的个数，此时如何定义才可以使参数个数更加灵活呢？–答案是，我们可以用*args或者**kargs，那..什么时候用 *args什么时候用**kargs呢？ 第一种情况1234def fun1(*args): print(args)fun1(10)fun1(10,20,30) 123#输出结果为元组(10,)(10, 20, 30) 因此，无法事先确定传递的位置形参的个数时，用*args定义个数可变的位置形参 第二种情况1234def fun2(**kargs): print(kargs)fun2(a=10)fun2(a=10,b=20,c=30) 123输出结果为字典&#123;&#x27;a&#x27;: 10&#125; &#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 20, &#x27;c&#x27;: 30&#125; 因此，无法事先确定传递的关键字实参的个数时，使用**kargs定义个数可变的关键字形参 返回值return 语句指定应该返回的值，该返回值可以是任意类型 需要注意的是，return 语句在同一函数中可以出现多次，但只要有一个得到执行，就会直接结束函数的执行。 没有返回值的情况只是完成一个操作，函数体内可没有return语句。调用会返回None 1234def fun(): print(&#x27;hello&#x27;) #return #return可以省略不写fun() #调用fun() 12输出结果为hello 有返回值的情况函数的最后会有一个返回值return，将函数执行的结果返出。 123def fun3(): return&#x27;hello&#x27;,&#x27;world&#x27;print(fun3()) #返回值是两个，要用到return 12#输出结果是元组(&#x27;hello&#x27;, &#x27;world&#x27;) 内置函数数字相关 bool() 将给定的数据类型转换成bool值。如果不给值，返回False int () 将给定的数据转换成int值。如果不给值，返回0 float () 将给定的数据转换小数 complex () 创建一个复数，第一个参数为实部，第二个参数为虚部。或者第一个参数直接用字符串来描述复数 1234number = &#x27;100&#x27;print(int(number)) # 100print(float(number)) # 100.0print(bool(10)) # True 进制转换 bin() 将给的参数转换成二进制 otc() 将给定的参数转换成八进制 hex() 将给定的参数转换成十六进制 1234number=25print(bin(number)) # 0b11001print(oct(number)) # 0o31print(hex(number)) # 0x19 数字运算 abs() 返回绝对值 divmode() 返回商的余数 round () 四舍五入 pow(a,b) 求a 的b 次幂,如果有三个参数.则求完次幂后对第三个数取余 sum() 求和 min() 求最小值 max() 求最大值 1234number = -10.58print(abs(number)) # 10.58print(round(number)) # -11print(max(number,-9)) # -9 列表和元组 list() 将一个可迭代对象转换成列表 tuple() 将一个可迭代对象转成元组 reversed() 将一个序列翻转, 返回翻转序列的迭代器 slice() 列表的切片，格式是(初:末 :step :) 12s = &#x27;hello&#x27;print(list(s)) # [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;] 123lst = &quot;hello! I am Running&quot;s = slice(1, 10, 3)print(lst[s]) # eoI 字符串相关 str () 将数据转换成字符串 format() 与具体数据相关,用于计算各种小数.精算等 memoryview() 查看bytes的内存中的情况 ord() 输入字符找带字符编码的位置 chr() 输入位置数字找对应的字符 ascii() 是sdcll码中的返回值 不是就返回\\u.. 123456789# 找到对应字符的编码位置print(ord(&#x27;s&#x27;)) # 115print(ord(&#x27;苏&#x27;)) #33487# 找到对应编码位置的字符*print(chr(115)) #sprint(chr(38597)) #雅,诶嘿嘿一不小心暴露真名# 在sacll码中就返回这个值. 如果不是就返回\\u..*print(ascii(&#x27;a&#x27;)) *# &#x27;a&#x27;*print(ascii(&#x27;苏&#x27;)) *# &#x27;\\u82cf&#x27; 数据集合 dict() 创建一个字典 set() 创建一个集合 frozenset() 创建一个冻结的集合.冻结的集合不能进行添加和删除操作 其他相关 len() 返回一个对象中的元素的个数 sorted() 对可迭代对象进行排序 enumerate() 获取集合的枚举对象 all() 可迭代对象中全部是True.结果才是True any() 可迭代对象中有一个是True,结果就是Ture zip() 函数用于将可迭代的对象最为参数.将对象中对应的元素打包成一个个元组 eval() 执行字符串类型的代码,并返回最终的结果 内存相关 hash() 获取到对像的哈希值(int str bool tuple) id () 获取到对象的内存地址 以上内置函数算是比较常用的，其他就不一一列举啦","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://0w0suy.github.io/tags/Python/"}]},{"title":"Mysql服务器的基本配置及访问办法","slug":"Mysql服务器的基本配置及访问办法","date":"2021-07-19T11:56:20.000Z","updated":"2021-07-21T03:39:15.886Z","comments":true,"path":"2021/07/19/Mysql服务器的基本配置及访问办法/","link":"","permalink":"https://0w0suy.github.io/2021/07/19/Mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%AE%BF%E9%97%AE%E5%8A%9E%E6%B3%95/","excerpt":"","text":"预备知识存在即合理，从两个问题开始引入mysql 1、“这是什么？” 2、“为什么要有这个？” 什么是数据库？数据库，是用来存储数据的。数据库由表组成，表由列组成。这个表就像Excel一样，它适合存放一些文字信息。比如，id、密码、电话号码、地址等等，但是它不适合存放单个大体量的文件对象，比如，电影、照片。 简单的举个栗子，比如说QQ中的数据库，会存放users的网名、密码、QQ号、个性签名等数据，但是qq空间的动态里的视频、音乐、图片可能就不会放在数据库里。 MySQL是什么？MySQL是一种数据库软件。数据库和MySQL的关系，就像是聊天软件与QQ、微信的关系。世界上有各种各样的数据库，比如Oracle、MySQL、SQL Server等等，一般互联网公司都会用MySQL，因为它是免费、使用范围最广。 MySQL已经成为当前网络中使用最多的数据库之一，特别是在Web应用上，它占据了中小型应用的绝对优势。这一切都源于它的小巧易用、安全有效、开放式许可和多平台，更主要的是它与三大Web语言之一——PHP的完美结合。 SQL是什么？SQL是一种编程语言，就像Java、C++、Python。它是用来操纵数据库的一种语言。只需要上百个英文单词，SQL就能对数据进行让人眼花缭乱的操作。 为什么要有数据库？数据库可以让很多人同时地进行访问、更改数据。而excel不能供一个大型系统使用，它的性能不够好。（想象一下数亿人同时操控一个Excel文件，啊，那真是不能想象，一定卡顿爆） 总的来说，数据库是一种数据存储系统，其中最具代表性的是mysql，我们使用sql语言对它进行操纵。 实验环境用户系统：Windows操作系统 工具：MySQL5.5软件 数据库安全实验1、安装MySQL 在MySQL官网上点download，进入MySQL Community server下载想要下载的版本，直接下载installer，不要下载zip压缩包（我下载的是5.5.29，截止到2021.07.19，最新版本是8.0.25，越稳定越好，随便下个5.5.29的） 几个非默认的页面需要注意一下（并非一直点next） 2、MySQL密码为安装时所设，键入后回车，界面如下。 3、运行下图命令，查看User表。 1use mysql 4、运行update命令，将MySQL数据库root用户的口令改成123456。其中最后一句命令flush privileges的意思是强制刷新内存授权表，否则用的还是缓冲中的口令，这时非法用户还可以用root用户及空口令登录，直到重启MySQL服务器。 12update user set password = password(&#x27;123456&#x27;) where user=&#x27;root&#x27;;flush privileges; 5、运行delete命令，删除空用户。Host字段为localhost的匿名用户拥有所有的权限，就是说本地用户用空的用户名和空的口令登录MySQL数据库服务器可以得到最高的权限，所以匿名用户必须删除。 12delete from user where user=&#x27;&#x27;;flush privileges; 6、Desc User User表是授权表中最重要的一个，运行下图命令，列出可以连接服务器的用户及其加密口令，并且它指定它们有哪种全局（超级用户）权限。在User表启用的任何权限均是全局权限，并适用于所有数据库。所以我们不能给任何用户访问MySQL. User表的权限。 1desc user; 7、Desc DB 运行下图命令，查看DB表，列出所有数据库，而用户有权限访问它们。在这里指定的权限适用于一个数据库中的所有表。 12use mysql;desc db; 8、Desc Host Host表如下图所示，与DB表结合使用在一个较好层次上控制特定主机对数据库的访问权限，这可能比单独使用DB好些。这个表不受GRANT和REVOKE语句的影响。 1desc host; 9、设置用户权限 如下图命令用于在本地增加一个具有所有权限的test 用户(超级用户)，密码是test。ON子句中的*.*意味着“所有数据库、所有表”。with grant option表示它具有grant权限。用grant语句创建权限是不需要再手工刷新授权表的，因为它已经自动刷新了。 12grant all privileges on *.* to test@localhost identified by &#x27;test&#x27; with grant option;select User,Password from user; 查看运行结果，如下图。 10、删除用户的权限，并删除用户 123revoke all on *.* from test@localhost;delete from user where user=&#x27;test&#x27;;flush privileges; 删除用户权限。 删除用户test。 到这就OK啦","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://0w0suy.github.io/tags/MySQL/"}]},{"title":"hexo根目录中_config.yml配置解释","slug":"hexo根目录中-config-yml配置解释","date":"2021-07-17T08:35:10.000Z","updated":"2021-07-21T03:39:15.894Z","comments":true,"path":"2021/07/17/hexo根目录中-config-yml配置解释/","link":"","permalink":"https://0w0suy.github.io/2021/07/17/hexo%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%AD-config-yml%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A/","excerpt":"","text":"前言在学习发博客的时候，经常会出现报错，而这些报错通常会让我们修改根目录中_config.yml某些配置，然而我也是不知所以然就”照本宣改”,甚至会想当然的改掉了原来一些配置，导致hexo d运行报错。因此，通过这篇blog对config的配置进行解释说明。 配置123`#Hexo Configuration``##Docs: https://hexo.io/docs/configuration.html``##Source: https://github.com/hexojs/hexo/` 第二、三行表示hexo文档的相关文档，Docs指的是hexo的文档，Source指的是hexo的Github源码。 网站Site1234567#sitetitle: Hexosubtitle: &#x27;&#x27;description: &#x27;&#x27;author: John Doelanguage: entimezone: &#x27;&#x27; title: 网站的名字，会写在hexo g命令生成后的public文件夹下的index.html文件的title标签里。 我们也可以在默认的主题的首页左下角找到 subtitle：网站的副标题，生成的时候默认为空，我们可以试着给他赋个值看它会出现在哪。 在这个默认的主题里，它写在背景图中间，也就是hexo的正下方。 author：顾名思义就是作者，这个也只是署个名而已language：这里就写了网站使用的语言，en表示英文timezone：网站对应的时区，一般情况下不用去刻意配置，会默认使用电脑的时区，但如果发布到其他地方的服务器，可能会使用当地服务器的时区，此时如果有需要用到本电脑的时区就要手动设置时区了，一般中国的时区可以设置为Asia/Shanghai 网址URL123456## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;##如果你的网站位于子目录中，请将网址url设置为&#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;url: https://0w0suy.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: url：网站的网址root：网站的根目录permalink：文章的永久链接格式 比如我的这篇blog，它的链接格式就是year/:month/:day/:title/ 并且在D:\\blog\\blog\\public\\2021\\07这里面，也是按照日期进行归类的 permalink_defaults：为permalink中各项的默认值 目录Directory12345678source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: source_dir：存放hexo文章的文件夹，我们写的md文件都放在这个配置对应的文件夹下，默认值是sourcepublic_dir：存放hexo g生成的文件，执行hexo g后根目录就会出现这个文件夹，默认值是publictag_dir：按标签存放文章的目录，默认值是tags，如果我们给文章添加标签，使用hexo g时public文件夹下就会多出一个tags文件夹（根据我们的配置文件夹名不同）比如到目前为止（2021.7.17)我的tag分为四类 archive_dir：归档文件夹，存放归档文件，默认值为archivescategory_dir：分类文件夹，按分类存放的文件，和上面的tags一样，只要在文章中的Font-matter添加了categories就会在使用hexo g构造时出现相应的文件夹，在D:\\blog\\blog\\public\\categories中 code_dir：Include code 文件夹，source_dir 下的子目录，默认值为downloads/codei18n_dir：国际化（i18n）文件夹，默认值:langskip_render：跳过指定文件的渲染，匹配到的文件将会被不做改动复制到public文件夹下，如果路径对应的是我们的文章，那会直接忽略掉该文章，我们这样设置来忽略掉hello-world.md文件 文章Writing1234567891011121314151617new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: new_post_name：新文章的默认名称，我们是使用hexo new来构造文章的，生成的文章名就是通过这里配置的，也就是标题.md，生成的md文件可以在D:\\blog\\blog\\source_posts中找到default_layout：预设布局，hexo new可以创建三种文件，post/帖子，draft/草稿，page/页面，这里设置默认值在使用hexo new就可以直接创建对应默认类型的文章，设置了post就等同于说在命令行执行hexo new 和执行hexo new post 是一样的，也可以设置为draft和page。所以我们在hexo new 的时候是默认生成post文件，而非draft和pagetitlecase：把标题转换为 titlecase，但因为为FALSE，所以不转化external_link enable：是否在新标签中打开链接，为TRUE fileds：external_link.enable的配置对当前网站（site）生效或仅对文章（post）生效，默认为site exclude：需要排除的域名 filename_case：把文件名称转换为小写(1)或者大写(2)，默认不转换(0) render_drafts：是否渲染草稿文件，默认为false不渲染post_asset_folder：是否启动资源文件夹，对于我们的网站，如果我们的文章里面有图片，我们可以在source文件夹下建立一个统一的images文件夹来存放图片，但是如果有的文章有很多的资源文件如图片，我们可以通过设置该配置为true，这样在source文件夹下创建文件的同时也会创建一个同名文件夹来存放相应的资源，比如我设置为true，然后执行hexo new “hexo根目录中_config.yml配置解释”，对应的，在D:\\blog\\blog\\source_posts中会生成一个匹配的文件夹，专门存放图片 relative_link：是否把链接改为与根目录的相对地址，默认为falsefuture：是否显示当前时间之后的文章，默认为true，如果设置为false的话，我们设置的日期如果是未来的日期的话，就不会显示highlight：代码块的设置 enable：开启代码高亮，默认为true auto_detect：如果未指定语言，就自动检测，默认为false line_number：显示代码的行数，默认为true tab_replace：用n个空格来代表tab键，如果值为空，则不会代替tab键 主页设置Home page setting1234567 # path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;&#x27; per_page: 10 order_by: -date index_generator：主页相关的设置 path：主页对应的路径，默认为 ‘ ‘，即域名根目录就是主页的路径 per_page：每页显示的帖子数，默认为10 order_by：帖子的排序，默认为-date，即按日期倒序排 分类和标签Category&amp;Tag123default_category: uncategorized category_map:tag_map: default_category: uncategorized 默认分类category_map:分类别名tag_map:标签别名 日期、时间格式Date/Time format12345## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss date_format：日期格式，默认为YYYY-MM-DD，即年月日time_format：时间格式，默认为HH:mm:ss，即时分秒 分页Pagination123## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page per_page：分页时每页的文章数，如果为0则不分页，默认为10pagination_dir分页的目录，默认为page，对应于public文件夹下的archives文件夹下的page文件夹，如果只有一页是不会生成这个文件夹的 主题Extensions123## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape theme: landscape # 当前使用的主题名 部署Deployment12345## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/0w0suy/0w0suy.github.io.git branch: master repo: # 库地址 branch: # 分支名称","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://0w0suy.github.io/tags/hexo/"}]},{"title":"Python实例1--文本进度条","slug":"Python实例1--文本进度条","date":"2021-07-16T00:15:48.000Z","updated":"2021-07-21T03:39:15.894Z","comments":true,"path":"2021/07/16/Python实例1--文本进度条/","link":"","permalink":"https://0w0suy.github.io/2021/07/16/Python%E5%AE%9E%E4%BE%8B1--%E6%96%87%E6%9C%AC%E8%BF%9B%E5%BA%A6%E6%9D%A1/","excerpt":"","text":"文本进度条的分析1、采用字符串方式打印可以动态变化的文本进度条 2、进度条需要能在一行中逐渐变化 3、采用sleep（）模拟一个持续的进度 文本进度条框架12345678910import timescale = 10print(&quot;-----开始阅读------&quot;)for i in range(scale+1): a = &#x27;*&#x27;*i b = &#x27;.&#x27;*(scale - i) c = (i/scale)*100 print(&quot;&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&quot;.format(c,a,b)) time.sleep(0.1)print(&quot;------阅读完毕------&quot;) 执行结果如下图 我们可以看到这个文本进度条包括百分比，”开始阅读”及”阅读完毕”的字眼，以及剩余阅读部分的进度条格式。 分析代码1import time 我们先引入一个time库，整体用sleep函数，来生成一个持续不断的时间。 123print(&quot;-----开始阅读------&quot;)print(&quot;------阅读完毕------&quot;) 我们打印了开始阅读和阅读完毕的字眼，为了使看起来更加美观，引入了减号”-“，字体居中。 1scale = 10 scale指的是文本进度条的大概宽度 1for i in range(scale+1): for循环，for i in range 这样的表达方式，表示遍历range（） 对象。之所以称为遍历循环，是因为for语句的循环执行次数是根据遍历结构中元素的个数确定的。遍历循环可以简单的理解为从遍历结构中逐一提取元素，放入循环变量中，对于每个所提取的元素执行一次循环体语句，当遍历结构中所有的元素都被访问遍了，遍历循环就正常结束。 放到进度条中，可以理解为，每经过一个循环，计算机完成一个任务，打印一个进度条，计算机再完成一个任务，再打印一个进度条。直到进度条百分百，即完成了任务，打印出“阅读完毕”。 1a = &#x27;*&#x27;*i 定义a，字符*与循环变量i的乘积 (在字符串中学过，字符串与整数的乘积表示字符串被复制的次数) 因此，a表示星号*被复制的次数，而星号指当前的百分比所表达的信息。 1b = &#x27;.&#x27;*(scale - i) 定义b，用.表示，与当前剩余的进度条的笔记之间的乘积。 1c = (i/scale)*100 c指的是我们输出与当前进度条和进度相关的百分比 1print(&quot;&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&quot;.format(c,a,b)) 前面我们学过，百分比%和括号{}，可以表示占位符。用三个占位符表示三个槽。&#123;:^3.0f&#125;%表示某%，[&#123;&#125;-&gt;&#123;&#125;]前者占位符表示星号*，即已阅读进度条，后者占位符表示点.，即剩余进度条。 1time.sleep(0.1) 表示将程序短暂的停顿1秒 单行动态刷新刷新的本质刷新的本质是用后打印的字符覆盖之前的字符。 比如说，截止到2021年7月16日9点19分，国内疫情实时大数据报告有9007979480人在浏览这个网页，当我刷新一次截止到2021年7月16日9点20分，这个数据变成了9007982317，用后面的数据覆盖了原来数据的位置，之前的数据被替换，对用户来说，这就是刷新效果。 这就需要我们的程序，在输出某一个 字符的字符串的时候，不能够换行到下一行。因为一旦换行到下一行，之前的数据就不能被后来的所覆盖。因为print函数执行完后会进行到下一行，所以我们要让print不能换行。并且要让光标退回到之前的位置，实现覆盖。 总而言之，刷新要做到两点: 1.不能换行 2.要能退回 代码如下： 1234import timefor i in range(101): print(&quot;\\r&#123;:3&#125;%&quot;.format(i),end=&quot;&quot;) time.sleep(0.1) 执行结果如下图 分析代码1import time 还是使用time库的sleep函数 1`for i in range(101):` 构造101次的循环过程。因为为了输入文本进度条，从0%到100 %，划分为101次。 1print(&quot;\\r&#123;:3&#125;%&quot;.format(i),end=&quot;&quot;) 在format后面增加了,end=&quot;&quot;，这是print函数的一个参数，end后字符串为空字符，表示print完不会增加新的内容，光标还是停留在最后一个字符上。\\r&#123;:3&#125;%表示在打印输出字符串之前，将光标退回到当前行的行首。 简单来说，在每次输出前，把光标放到行首，覆盖原来的数据，在输出后也不换行，下一次循环再输出的时候，再把光标放到行首，覆盖上次的数据后，再输出，又不换行。这样就构成了一种单行刷新的效果。 1time.sleep(0.1) 表示将程序短暂的停顿1秒 分析结果我们看到的是从0%到100%的结果，但实际上是一个一个覆盖刷新的效果。因为IDLE本身是一个编写式的开发环境，它并不是程序运行的主要环境。 进度条的改进完善运用知识1、字符串处理 2、数字处理 3、时间库的使用 123456789101112import timescale = 50print(&quot;开始阅读&quot;.center(scale//2,&quot;-&quot;))start = time.perf_counter()for i in range(scale+1): a = &#x27;*&#x27;*1 b = &#x27;.&#x27;*(scale - i) c = (i/scale)*100 dur = time.perf_counter() - start print(&quot;\\r:&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c,a,b,dur),end=&quot;&quot;) time.sleep(0.1)print(&quot;\\n&quot;+&quot;阅读完毕&quot;.center(scale//2,&quot;-&quot;)) 运行结果如下图 区别： print(&quot;-----开始阅读------&quot;) print(&quot;开始阅读&quot;.center(scale//2,&quot;-&quot;)) 刚开始我们为了让结果看起来更美观，用减号-来分隔，但如果页面布局或大小变化，这样显得不太智能。现在我们使用字符串处理中的.center方法，将一个-字符填充在执行开始或者执行结束的两侧，通过填充的方式，自动实现减号构成的分隔线条。 并且我们还增加了计时效果start = time.perf_counter()，确定了一个开始时间，而 dur = time.perf_counter() - start表示每次循环所消耗的时间。 print(&quot;\\r:&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c,a,b,dur),end=&quot;&quot;)中的\\n ，表示文本的刷新效果，实现光标向行首移动。end=&quot;&quot;表示每次输出后不换行。 进度条的举一反三计算问题扩展文本进度条程序使用了perf_counter()计时，计时方法适合各类需要统计时间的计算问题。 在上文我们可以看到在每次打印进度条后，会加上一个时间，即相隔循环打印时间。这样我们就可以用perf_counter()来比较不同算法时间、统计部分程序运行时间。 进度条应用扩展不仅可以应用于文本进度条，也可以在大型加载的程序中增加进度条，因为进度条是人机交互的桥梁，通过进度条我们可以直观的看到计算机运行的进度，可以给我们带来对程序更好的理解。","categories":[{"name":"实例","slug":"实例","permalink":"https://0w0suy.github.io/categories/%E5%AE%9E%E4%BE%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://0w0suy.github.io/tags/python/"}]},{"title":"markdown的基础语法","slug":"markdown的基础语法","date":"2021-07-14T03:37:28.000Z","updated":"2021-07-21T03:39:15.894Z","comments":true,"path":"2021/07/14/markdown的基础语法/","link":"","permalink":"https://0w0suy.github.io/2021/07/14/markdown%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"前言写过博客的都知道Markdown语法的重要性，否则就会像我一样，在 hexo d 后出现warn警告。这篇博客将轻松搞定Markdown语法~ 一、快捷键 功能 快捷键 加粗 Ctrl+B 斜体 Ctrl+I 引用 Ctrl+Q 插入链接 Ctrl+L 插入代码 Ctrl+K 插入图片 Ctrl+G 有序列表 Ctrl+O 无序列表 Ctrl+U 横线 Ctrl+R 撤销 Ctrl+Z 保存 Ctrl+S 二、基本语法2.1 字体设置 输入内容 显示效果 文本前后各加一个”*” 0w0suy斜体 文本前后各加一个”_” 0w0suy 斜体 文本前后各加两个”*” 0w0suy加粗 文本前后各加三个”*” 0w0suy斜体加粗 文本前后各加一个”~” 0w0suy下划线 2.2 分级标题 输入内容 显示效果 文本前加一个”#” 一级标题 文本前加两个”#” 二级标题 文本前加三个”#” 三级标题 文本前加四个”#” 四级标题 注意：#后空一格在输入文本 2.3 链接2.3.1 插入本地图片链接![图片描述](图片路径&quot;title&quot;) 2.3.2 插入网络图片只需要在语法的括号中填入图片的网络链接即可例如： 2.4 分割线在一行中输入三个”*”,”-“,”_”都可以建立分割线，行内不能有其他东西，分割线效果如下 2.5 代码块在写博客的时候，插入代码块这个功能是必不可少的，如果不插入代码块，就没办法直观地显示出代码指令，从而直接运行代码插入代码块的方式有两种，一种是利用缩进（tab），另一种是利用英文反引号符号（在英文输入法下，与~同键，按一下即可打出`） 2.5.1代码块缩进4个空格或者按一下tab键，接着输入代码 2.5.2行内式在一个行内需要引用代码的话，只要用反引号就可例如，我的ID是 0w0suy 2.5.3多行代码块与语法高亮在需要高亮的代码块的前一行和后一行使用三个反引号即可,如下图 1print(&quot;hello world&quot;) 2.5.4代码块里面包含html代码在代码区块里面，&amp;、&lt;、&gt;，会自动转化成HTML实体 2.6 引用2.6.1基本使用在被引用的文本前面加上”&gt;”符号，并空格，使用效果如下 0w0suy 这是输入内容： &gt;0w0suy 2.6.2嵌套引用使用效果如下 引用1引用2引用3 这是输入内容：&gt;&gt;&gt;引用1，&gt;&gt; 引用2，&gt; 引用3 2.7 表格以第一大点的快捷键中表格制作为例，表格的基本写法跟表格的形状很相似代码及效果图如下: 12345功能 | 快捷键 |- | - | 加粗 | Ctrl+B斜体 | Ctrl+I引用|Ctrl+Q 功能 快捷键 加粗 Ctrl+B 斜体 Ctrl+I 引用 Ctrl+Q 三、常用技巧3.1 换行方法1：连续按两个以上空格+回车方法2：使用HTML语言换行标签 3.2 缩进字符&amp;nbsp;我爱学习 &nbsp;我爱学习（缩进四分之一中文） &amp;ensp;我爱学习 &ensp;我爱学习 （缩进半个中文，1字符） &amp;emsp;我爱学习 &emsp;我爱学习 （缩进1个中文，2字符） 3.3 特殊符号3.3.1基本符号对于Markdown中的语法符号，前面加反斜线\\即可显示符号本身格式为\\符号\\反斜线*星号_下划线#井号.句点!感叹号 3.3.2特殊符号&amp;#10084; &#10084;&amp;#10003; &#10003;&amp;#9728; &#9728;&amp;#9733; &#9733;&amp;#9730; &#9730;&amp;#9775; &#9775;&amp;#10052; &#10052;&amp;#9835; &#9835;想知道更多的字符对应的unicode码，可以看这个网站：https://unicode-table.com/cn/ 3.4 字体、字号、颜色、背景色Markdown本身不支持修改字体、字号与颜色等功能 3.5 链接的高级操作3.5.1行内式参考上文语法，在一个行内需要引用代码的话，只要用反引号就可例如，我的ID是 0w0suy 3.5.2参考式链接在文档要插入图片的地方写 ![图片或网址链接][标记]，在文档的最后写上[标记]:图片地址”标题” 3.5.3 内容目录在段落中填写[top]以显示全文内容的目录结构 3.5.4 注脚3.6 emoji表情符号四、高端用法4.1 LaTeX数学公式4.2 流程图4.3 TODO列表4.4 绘制序列图五、Markdown工具","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://0w0suy.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://0w0suy.github.io/tags/Markdown/"}]},{"title":"github＋hexo懒人搭建博客完整教程","slug":"github＋hexo懒人搭建博客完整教程","date":"2021-07-07T15:51:20.000Z","updated":"2021-07-21T03:39:15.894Z","comments":true,"path":"2021/07/07/github＋hexo懒人搭建博客完整教程/","link":"","permalink":"https://0w0suy.github.io/2021/07/07/github%EF%BC%8Bhexo%E6%87%92%E4%BA%BA%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/","excerpt":"","text":"一、准备1.1环境搭建搭建博客首先是准备环境的搭建，这就像我们体内的细胞依赖于内环境而存活，内环境为细胞的生活提供的必要的水环境以及其它物质交换的通道。我们搭建的环境也是如此。先安装 Node.js 和 Git，因为Hexo 基于 Node.js。附上下载的官网链接Node.js：https://nodejs.org/zh-cnGit：https://git-scm.com/downloads下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。安装完成后，Win+R 输入 cmd 并打开（或者左下角点查找），依次输入 node -v、npm -v 和 git –version（注意空格） 并回车，出校如下图表示成功。 1.2注意事项敲代码的时候，将输入法换成英文输入。统一使用 Git Bash 进行操作。注意空格。 二、连接 Github使用邮箱注册 GitHub 账户，选择免费账户（Free），并完成邮件验证。在桌面的页面，在空白处右键鼠标点【Git Bash Here】开始运行，设置用户名和邮箱。（注意：用户名是自己的github账户名，邮箱是绑定的邮箱）‘’’git config –global user.name “GitHub 用户名”git config –global user.email “GitHub 邮箱”‘’’创建 SSH 密匙输入 ssh-keygen -t rsa -C “GitHub 邮箱”，然后一路回车。添加密匙：进入 [C:\\Users\\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。验证连接：打开 Git Bash，输入 ssh -T &#x67;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d; 出现 “Are you sure……”，输入 yes 回车确认。显示 “Hi xxx! You’ve successfully……” 即连接成功。 三、创建 Github Pages 仓库GitHub 主页右上角加号 -&gt; New repository：Repository name 中输入 用户名.github.io勾选 “Initialize this repository with a README”Description 选填填好后点击 Create repository 创建。创建后默认自动启用 HTTPS，博客地址为：https://用户名.github.io 四、本地安装 Hexo 博客程序新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。 4.1. 安装 Hexo使用 npm 一键安装 Hexo 博客程序：npm install -g hexo-cli稍等一会后，会出现如下图的代码 4.2. Hexo 初始化和本地预览初始化并安装所需组件：hexo init # 初始化npm install # 安装组件完成后依次输入下面命令，启动本地服务器进行预览：hexo g # 生成页面hexo s # 启动预览访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！ 五、部署 Hexo 到 GitHub Pages本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。首先安装 hexo-deployer-git：npm install hexo-deployer-git –save然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：‘’’deploy: type: git repository: &#103;&#105;&#x74;&#64;&#103;&#105;&#116;&#104;&#117;&#98;&#46;&#x63;&#111;&#109;:用户名/用户名.github.io.git branch: master‘’’完成后运行 hexo d 将网站上传部署到 GitHub Pages。完成！这时访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。 六、绑定域名（可选）因为我用的是免费的github域名，就没有绑定域名。域名注册和解析这步过程略。七、开始使用详情见下一篇博客7.1. 发布文章7.2. 网站设置7.3. 更换主题7.4. 常用代码 八、常见问题详情见下一篇博客","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://0w0suy.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://0w0suy.github.io/tags/hexo/"}]},{"title":"关于blog常见报错及解决方法","slug":"关于blog常见报错及解决方法","date":"2021-07-07T05:36:34.000Z","updated":"2021-07-21T03:39:15.894Z","comments":true,"path":"2021/07/07/关于blog常见报错及解决方法/","link":"","permalink":"https://0w0suy.github.io/2021/07/07/%E5%85%B3%E4%BA%8Eblog%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言在发blog的时候，经常会遇到一些重复性的报错问题，这些报错感觉都很眼熟，好像每天都会遇到（笑哭）。第一次看不懂报错，直接复制粘贴甩给百度翻译，但是就算翻译成中文人也还是懵逼的。比如这样 又或是这样 或许是那样 等等等等… 第二次第三次又遇到一样的情况，索性就整理出来吧。（持续更新） hexo d报错解决：OpenSSL SSL_read: Connection was reset, errno 10054 错误解决首先，造成这个错误很有可能是网络不稳定，连接超时导致的， 如果再次尝试后依然报错，可以执行下面的命令 在D:\\blog\\blog中打开Git-Bash命令页面，执行git命令脚本：修改设置，解除ssl验证 1git config --global http.sslVerify &quot;false&quot; 此时，再执行hexo d即可解决 hexo s 报错解决(node:15260) Warning 很简单 不用管它 （警告而已warning,我也不知道为什么还能运行qwq)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://0w0suy.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"Hello World","date":"2021-07-06T06:09:11.479Z","updated":"2021-07-24T02:19:42.585Z","comments":true,"path":"2021/07/06/Hello World/","link":"","permalink":"https://0w0suy.github.io/2021/07/06/Hello%20World/","excerpt":"","text":"Welcome to Hexo! This is my very first post！ I want to take you to know a bunch of budding cells~There are about 37,200 billion cells in the human body that work 24 hours a day, 365 days a year. “You work it at work, you sleep it’s still working, you get hurt it takes protective measures, every breath you take, every movement, every eyelash wink, it’s all about them … How do they work? Do you really understand? Budding cells首先出场的是我们的女一号氧气快递员，路痴职场新手红细胞妹子 The first to appear is our female No. 1 oxygen courier, Lu crazy workplace novice red blood cell sister 红细胞无细胞核，呈两面凹的圆饼状，内有一种红色含铁的蛋白质。寿命在120天左右，她的工作就是将氧气搬运到身体的各个角落，并将二氧化碳送回肺部。动画中红细胞这个职场新手萌妹子比较容易迷路。她静脉瓣膜、淋巴血管、脾脏、肾脏都走了一遍，就是没找到肺部。最后竟然碰上了肺炎链球菌，差点没命。还好，男主角及时出现，英雄救美 接下来是我们的男一号，外冷内热的白细胞。 Next up is our male number one, the outer cold inner hot white blood cells. 白细胞是免疫细胞，具有免疫功能，当我们身体被细菌感染了，它们会奋起反击，主要通过吞噬和产生抗体等方式，抵御和消灭入侵到体内的病原微生物。白细胞分为中性粒细胞、嗜酸性细胞、嗜碱性粒细胞、单核细胞、淋巴细胞。它们的画风一般只在“癫狂地杀敌”和“冷漠地巡逻”中切换，动画中白细胞1146号，就是白细胞中的中性粒细胞。 动画中最撩人的凝血小妖精血小板 The most sedulous clotting goblin platelet in the animation 血小板，同红细胞、白细胞并称为三大血细胞，主要功能是促进止血和加速凝血，以及维护毛细血管壁的完整。动画中的血小板，是一群超级萌的小朋友！集体行动，擅长修修补补。如果我们身体擦伤，除了白血球会去和入侵的细菌格斗外，可爱的血小板也会迅速集合，一起奔往我们的伤口，帮助我们形成血栓，防止外界更多的细菌入侵。 有的网友看了后表示，以后伤口的疤再也不舍得揭了，原来他们都是可爱的血小板….. 最喜欢血小板啦(≧∇≦)ﾉ 擅于伪装的美丽猎人巨噬细胞 Beautiful hunters who are good at camouflage macrophages 巨噬细胞主要作用是清除体内衰老损伤或凋亡的细胞，以及免疫复合物和病原体等抗原性异物，捕获并吞噬细菌等异物，动画中造型是穿着女仆装持有强大武器的美丽的大姐姐，外表甜美，关键时刻，扛起大刀，比谁都能打。巨噬细胞不只是单打独斗，人体是一个系统，这里也讲团队合作。巨噬细胞发现病毒后，还会通知给树突状细胞, 然后树突状细胞会通知各个器官，让杀手T细胞立刻赶来支援。 (♥∀♥) 邮差小哥树突状细胞 Postman’s little brother dendritic cells 树突状细胞是机体功能最强的专职抗原递呈细胞，它能高效地摄取、加工处理和递呈抗原。因其成熟时伸出许多树突样伪足样突起而得名。动画里树突状细胞是个邮差小哥，很明显它的功能就是传递信息，主要负责收集、递呈入侵细菌和遭受感染的细菌信息，并与其它细胞相互作用，启动适当的免疫反应。 强悍特警杀伤性T细胞 Strong special police kill T-cells 如果白细胞是普通警察，杀手T细胞就是“特警”，病毒太难缠，他们就出手了。它们直接听命于辅助T细胞指挥官，可以反复杀伤病毒异物，而本身不受损伤。 记忆T细胞 Memory T cells 这位手中的小本本，就知道它的功能是做记录的，对于每次的反攻，他都要记录下来，以备下次再用，记忆T细胞会在下一次抗原入侵时再次将记忆中的杀毒方法再次调动出来，再次破坏靶细胞即受病菌或病毒感染的细胞，释放出靶细胞中的抗原，在再次免疫应答中起重要作用。 除了这些守护我们身体的正面角色，反面角色有哪些？当然是各种细菌病毒了。 重点说说“肺炎链球菌” 肺炎链球菌是引起肺炎等呼吸器官疾病的病原细菌，是有荚膜包裹的毒性极强的细菌。会侵入肺细胞并且破坏红血球，也是最坏能够破坏脑部的病原体，不仅可以导致儿童肺炎，而且还是引发脑膜炎、中耳炎等疾病。 每当肺炎链球菌入侵肺部后，对于身体内的免疫细胞来说，无异于一场灾难。我们身体的红细胞受到大量的损伤，白血球、T细胞浴血奋战，拼死将细菌消灭，而对人类而言，不过打了一个喷嚏，没想到吧，你一个喷嚏体内的动静竟有那么大。 此外还有金黄色葡萄球菌、酿脓链球菌、流感病毒……这些邪恶的反派，虽然说是反派，但是也萌蠢萌蠢得让人恨不起来…… 最后，《工作细胞》送给努力工作的你，你身体内的细胞们为了这个身体的正常运行都这么拼命，你作为这具身体的主人更该为自己，为工作细胞们负责。养成好的生活习惯，减少身体里这群可爱细胞们的工作量。 Finally, “Working Cells” to hard-working you, the cells in your body for the normal operation of the body are so desperate, you as the owner of this body more for themselves, for the work of the cells responsible. Develop good habits and reduce the workload of these cute cells in your body.","categories":[],"tags":[]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://0w0suy.github.io/categories/CTF/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://0w0suy.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实例","slug":"实例","permalink":"https://0w0suy.github.io/categories/%E5%AE%9E%E4%BE%8B/"},{"name":"使用教程","slug":"使用教程","permalink":"https://0w0suy.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://0w0suy.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Python","slug":"Python","permalink":"https://0w0suy.github.io/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"https://0w0suy.github.io/tags/MySQL/"},{"name":"hexo","slug":"hexo","permalink":"https://0w0suy.github.io/tags/hexo/"},{"name":"python","slug":"python","permalink":"https://0w0suy.github.io/tags/python/"},{"name":"Markdown","slug":"Markdown","permalink":"https://0w0suy.github.io/tags/Markdown/"}]}